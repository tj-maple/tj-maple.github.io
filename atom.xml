<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://www.unknown9t.com/atom.xml" rel="self"/>
  
  <link href="http://www.unknown9t.com/"/>
  <updated>2020-03-26T02:06:30.475Z</updated>
  <id>http://www.unknown9t.com/</id>
  
  <author>
    <name>Maple</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见素数筛</title>
    <link href="http://www.unknown9t.com/2022/04/29/%E5%B8%B8%E8%A7%81%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    <id>http://www.unknown9t.com/2022/04/29/%E5%B8%B8%E8%A7%81%E7%B4%A0%E6%95%B0%E7%AD%9B/</id>
    <published>2022-04-29T13:54:56.310Z</published>
    <updated>2020-03-26T02:06:30.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在数学的王国里，质数（也即素数）是数这个范围内一枚闪闪发光的重要宝石，很多公式和定理都与素数有关。这样，如何判断一个数是否是素数也是一个重要的问题，只不过这个问题的解法相当显而易见，那么我们的目光就要更多的放在对于判断素数的算法的性能的优化上了（更多的是时间复杂度）。</p><span id="more"></span><p>有关质数的定义和性质在这里就不过多阐述了，我在本篇文章中主要讲解三种素数筛法，分别是朴素筛，埃筛以及欧筛（再有别的我就不知道了……菜的我）。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="朴素筛"><a href="#朴素筛" class="headerlink" title="朴素筛"></a>朴素筛</h2><p>平时大家最常用的应该就是朴素筛了，这种筛法的原理依赖于素数的定义：在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。这样就衍生出了一种判断素数的方法，即把当前需要判断的数n作为被模除数，用n不断从2开始到n-1尝试模除，如果结果等于0，代表可以整除，即也代表该数除了1与它本身有其他因数，故不符合素数定义，达到判断素数的功能。</p><h3 id="原理论证"><a href="#原理论证" class="headerlink" title="原理论证"></a>原理论证</h3><p>朴素筛的原理在上面大概讲清楚了，在这里我们主要论证两个问题。一个是从模除（2<del>n-1）优化到模除（2</del>sqrt(n)）的原理，还有就是对于朴素筛的时间复杂度的估算（虽然很简单）。</p><p>这里先摆出一段判断2<del>n所有数是质数还是合数的核心代码（模除2</del>i-1）</p><p>a数组中0代表该数是合数、1代表该数是质数</p><pre><code>for(int i=2;i&lt;=n;i++)&#123;    for(int j=2;j&lt;=i-1;j++)    &#123;        if(i%j==0)        &#123;            a[i]=0;            break;        &#125;    &#125;&#125;</code></pre><p>a数组在一开始都被赋了1为初值，代表所有数在未判别之前默认是质数（1除外，1另外赋值为0，因为不需要判断），当i（待判断数）能够整除j，则说明j是i的一个非1非本身因子，也即说明i不是一个质数，就可以赋值为0，不需要再向下进行尝试了。</p><p>通过这里很明显可以得出大概时间复杂度为O(N^2)。</p><p>再看一段经过优化的核心代码（模除2~sqrt(i)）</p><pre><code>for(int i=2;i&lt;=n;i++)&#123;    for(int j=2;j&lt;=sqrt(i);j++)    &#123;        if(i%j==0)        &#123;            a[i]=0;            break;        &#125;    &#125;&#125;</code></pre><p>这段代码的时间复杂度很明显也可以得出大概为O(N&amp;radic;N)。</p><p>现在我们来论证一下这个小优化的正确性。</p><p>首先我们可以看出来，这么优化造成的结果是不再尝试模除（sqrt(i)~i-1）区间的数。那么，不尝试这些数会不会对最终的判断结果造成什么影响呢？</p><p>我们知道sqrt(i)&amp;times;sqrt(i)的结果就是i，那么当一个数x&gt;sqrt(i)时，如果i%x&#x3D;&#x3D;0，那么在2~sqrt(i)这个区间内一定有一个数k，能够使得i%k&#x3D;&#x3D;0，因为k&amp;times;x等于i。这样，在后面的区间内，如果存在i的非1非本身因子，则在前面的区间里，也存在这样一个因子，所以不需要遍历后面的区间了。</p><p>另外，我遇到过有一些题目，会对这个小优化的时间复杂度进行限制，不用的话会TLE。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123;    int n;//假定5000以内     int a[5005];    scanf(&quot;%d&quot;,&amp;n);    a[1]=0;    for(int i=1;i&lt;=n;i++)    &#123;        a[i]=1;    &#125;    for(int i=2;i&lt;=n;i++)    &#123;        for(int j=2;j&lt;=sqrt(i);j++)        &#123;            if(i%j==0)            &#123;                a[i]=0;                break;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)    &#123;        printf(&quot;%d\n&quot;,a[i]);    &#125;    return 0;&#125; </code></pre><p>在这里我是用了一个数组来记录所有数是质数还是合数，但是在实际题目中，这个需求会有很多种，常见的可能会输出质数表或者判断某个数是否是质数，这可以视题目要求再进行具体变化。</p><h2 id="埃筛"><a href="#埃筛" class="headerlink" title="埃筛"></a>埃筛</h2><p>埃筛是埃拉托斯特尼筛的简称，又叫(Eratosthenes筛)。是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。（百度百科）</p><p>埃筛通过提前标记质数的倍数为合数避免了很多数的判断，相当于利用了质数的性质进行了算法的优化，成功的降低了时间复杂度。</p><h3 id="原理论证-1"><a href="#原理论证-1" class="headerlink" title="原理论证"></a>原理论证</h3><p>我们在放出代码之后再进行埃筛的时间复杂度分析，现在这里主要来论证埃筛的大致原理以及埃筛内容中的一点小优化。</p><p>正如上面所说，埃筛的思想大概就是利用了质数不能有非1非本身其他因子的出现，而质数的倍数一定是一个合数这个性质（其实合数的倍数也是合数，但是合数的倍数会在之前被标记到），避免了外部循环遍历到该质数时的朴素判断。</p><p>原理上来说，我们仍然在一开始假定所有数都是质数，从2开始，对2的所有小于n的倍数进行标记，标记它们为合数，在之后的遍历中，如果遍历到合数则无需再次判断，也不需要再标记该合数的倍数（因为该合数的倍数一定也是标记这个合数的质数的倍数，一定也已经被标记过了）。而遍历到3时，3没有被标记为合数，则需标记3的倍数······</p><p>标记的结果如下图所示，1既不是质数也不是合数，所以用黑色涂满。2、3、5、7的倍数分别用蓝色、橙色、绿色、紫色来涂满。剩下的白色的数代表质数。</p><p><img src="https://www.z4a.net/images/2020/03/26/1.1.2.png" alt="1.1.2.png"></p><p>那么这里有一个问题，我们可以直观地看出3是个质数，它被筛过理所应当，但是有没有合数被错误的筛过呢？</p><p><img src="https://www.z4a.net/images/2020/03/26/1.2.png" alt="1.2.png"></p><p>我们现在假设一个数x为合数，而x一定存在至少一个非1非本身因数a（可能两个因数相同）。假设a本身是个合数，则它与x本质上没有区别，仍然至少存在一个非1非本身因数。而假设a本身是个质数，则该合数就已经被标记。而假如该数a是合数，a因数也是一个合数，也不过是将这个判断过程不断传递下去，最终会在一个无法被分成合数&amp;times;合数的节点上变成质数&amp;times;质数或者是质数&amp;times;合数。总归是会被一个质数标记的，这样子就证明了埃筛理论上的严谨性与健壮。</p><p>现在我们来说一点小优化</p><p><img src="https://www.z4a.net/images/2020/03/26/1.3.2.png" alt="1.3.2.png"></p><p>埃筛的基础思想是对质数的倍数进行标记，我们很容易就可以在前几个质数中发现重复判断的数（如上图所示红圈圈出来的），在2的倍数时，2&amp;times;3&#x3D;6需要被标记，但是在3的倍数时，3&amp;times;2&#x3D;6也需要被标记一次，这里就造成了重复判断，而随着n的增大，这样的重复判断会越来越多，造成时间浪费，所以，这里衍生出了一种巧妙地小优化。就是在对i的倍数进行标记时（假设i已经是个质数），从i&amp;times;i开始判断，即从i的i倍开始判断。</p><p>那么这么优化到底有没有道理呢？我们来看一看。</p><p>对于3&amp;times;2（3的2倍）需要打标记这次判断，3的2倍也同样是2的3倍，就不用再进行判断了，故i&#x3D;3时，可以从i本身也就是3倍开始进行标记。有的读者可能会说，这是两个质数相乘，那如果一个质数和一个合数相乘呢？（不要说两个合数，动动脑子）。我们来看，首先，不可能遍历到一个合数然后标记该合数的质数倍（前面已经说明了）。所以，如果出现这种情况，那一定是遍历到一个质数然后标记该质数的合数倍，我们举个例子。假设遍历到5，此时应该标记5&amp;times;4&#x3D;20这个数为合数，那么在之前，这个数有没有被标记过呢？</p><p>显而易见，20是2的倍数，被标记过了。那20被标记的过程是怎么样的呢？20作为一个合数4的倍数，也是标记4的质数2的倍数，所以在遍历2时就会被标记，所以质数和合数相乘时，从i&amp;times;i开始记录也是有所证明的。</p><p>还有一个小优化也就是在一开始百度百科中说的那样，只需要去标记不大于根号n的所有素数的倍数，这样做也是有实际理论依据的。刚刚我们已经证明了对于一个质数i，从i&amp;times;i开始标记的正确性，那么对于一个大于根号n的质数j，我们不标记它的倍数会不会有问题。</p><p>事实上是不会的，因为j&amp;times;j必然大于n，不需要判断。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123;    int n;    int a[5005];    scanf(&quot;%d&quot;,&amp;n);    for(int i=2;i&lt;=n;i++)    &#123;        a[i]=1;    &#125;    a[1]=0;    for(int i=2;i&lt;=sqrt(n);i++)    &#123;        if(a[i]==1)//如果是质数         &#123;            for(int j=i*i;j&lt;=n;j+=i)            &#123;                a[j]=0;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)    &#123;        printf(&quot;%d=%d\n&quot;,i,a[i]);    &#125;    return 0;&#125;</code></pre><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>埃筛的时间复杂度很神奇的是O(nloglogn)，我们一般看到的时间复杂度都是O(n),O(n^2),O(logn)，几乎很少看到这种时间复杂度。</p><p>看到之后我就去网上搜关于欧筛的时间复杂度的证明，也算是找到了几个。</p><p>我把地址放在下面，正确性不明确（我也没证，只是简单的看了看），有兴趣的读者可以自行证明。</p><p><a href="https://blog.csdn.net/Gavin_Nicholas/article/details/88974079" title="https://blog.csdn.net/Gavin_Nicholas/article/details/88974079">https://blog.csdn.net/Gavin_Nicholas&#x2F;article&#x2F;details&#x2F;88974079</a></p><p><a href="https://blog.csdn.net/OIljt12138/article/details/53861367" title="https://blog.csdn.net/OIljt12138/article/details/53861367">https://blog.csdn.net/OIljt12138/article/details/53861367</a></p><p>在这里膜拜两位大佬。</p><h2 id="欧筛"><a href="#欧筛" class="headerlink" title="欧筛"></a>欧筛</h2><p>欧筛是欧拉筛的简称，也叫（Euler筛），又叫线性筛，时间复杂度达到O(n)而得名。</p><p>欧筛是埃筛的优化版本，在埃筛的介绍中，我们提到了埃筛的重复判断以及埃筛的小优化，但是埃筛本身的小优化并不能够完全去除重复筛选，只能去除两个因数相同的判断，对于因数不同的两次判断便无能为力了。我们来看12这个数。12&#x3D;3&amp;times;4&#x3D;2&amp;times;6，也就是说12这个数在埃筛中，会作为2的6倍筛一次，又会作为3的4倍筛一次，埃筛本身没有处理这个问题，于是引出了欧筛。</p><p>欧筛本身的思想是对于每个合数，只筛最小质数的倍数那一次。</p><h3 id="原理论证-2"><a href="#原理论证-2" class="headerlink" title="原理论证"></a>原理论证</h3><p>欧筛的思想没有什么新的思路需要证明，就在这里讲解一下欧筛的实现过程。</p><p>欧筛的思想很好理解，但是代码实现不算很简单，需要作出一定思考：如何才能做到，永远只用最小质数筛合数。</p><p>其实如果能想到这点就能想到，每次对于某一个数来说，如果这个数是质数，就把它记在一个数组里，做成一个素数表，用以查找。遍历每一个数i，让这个数i作为对之前所记录的所有质数的倍数来求得某一个质数的所有倍数。乍看起来好像并不严谨，但仔细思考之后会发现，这跟埃筛的i&amp;times;i开始有异曲同工之妙，而且这样做还可以方便的对于每一个数去遍历质数表，找到这个数的最小质因数，从而停止对该合数的多余判断。</p><p>假如i%prime[j]&#x3D;&#x3D;0，那么j这个位置放的质数就是i的最小质因子了，prime[j+1]没有再去乘i的必要了。（prime数组是质数表）</p><p>可以先尝试阅读代码，代码下面有图解。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>#include&lt;stdio.h&gt;#include&lt;math.h&gt;int prim[5005];int num=0,sum=0;int a[5005];int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    for(int i=2;i&lt;=n;i++)    &#123;        a[i]=1;    &#125;    a[1]=0;    for(int i=2;i&lt;=n;i++)    &#123;        if(a[i]==1)        &#123;            num++;            prim[num]=i;        &#125;        for(int j=1;j&lt;=num;j++)        &#123;            sum++;            if(i*prim[j]&gt;n)            &#123;                break;            &#125;            a[i*prim[j]]=0;            if(i%prim[j]==0)            &#123;                break;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)    &#123;        printf(&quot;%d=%d\n&quot;,i,a[i]);    &#125;    printf(&quot;%d&quot;,sum);    return 0;&#125;</code></pre><p><img src="https://www.z4a.net/images/2020/03/26/2.1.png" alt="2.1.png"></p><p>虽然代码是我自己后来打的，但是大概还是先看了一篇博客的讲解，在这里给出这篇博客的地址。</p><p><a href="https://www.jianshu.com/p/2031036dba4b" title="https://www.jianshu.com/p/2031036dba4b">https://www.jianshu.com/p/2031036dba4b</a> </p><p>总感觉欧筛还有别的实现方法，但在此先只说这一种吧，如果过后有所发现再补充。</p><h3 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>欧筛的时间复杂度众所周知O(n)（不然为啥叫线性筛啊）。</p><p>可以很明显看出来，对于每一个数，都只判断了一次，也即对于每一个数，时间复杂度是O(1)。</p><h3 id="欧筛拓展-ge-pi"><a href="#欧筛拓展-ge-pi" class="headerlink" title="欧筛拓展(ge pi)"></a>欧筛拓展(ge pi)</h3><p>跟欧筛有关的还有一个欧拉函数</p><p>欧筛求素数表可以直接求得欧拉函数</p><blockquote><p>在数论，对正整数n，欧拉函数是小于或等于n的正整数中与n互质的数的数目（因此φ(1)&#x3D;1）。此函数以其首名研究者欧拉命名(Euler’s totient function)，它又称为Euler’s totient function、φ函数、欧拉商数等。 例如φ(8)&#x3D;4，因为1,3,5,7均和8互质。 从欧拉函数引伸出来在环论方面的事实和拉格朗日定理构成了欧拉定理的证明。</p><p>————百度百科</p></blockquote><p>（具体的没咋看，过段时间再看，先到这里吧）</p><h1 id="其他筛法"><a href="#其他筛法" class="headerlink" title="其他筛法"></a>其他筛法</h1><p>其实这些天在准备这篇博客的时候，也有看到很多别的筛法，就不举例子了，在这里只列举了三种最常见的筛法吧。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>好多天没有写博客了，这些字基本上一个上午码出来的，但是事先的查资料，捋顺思路还是花了一些时间，可能是最近心思没在这些上面吧，后面会慢慢回来。</p><p>筛法大多是模板题，正式比赛筛法也基本上是作为预处理出现的，预处理的话总感觉朴素筛用处不大（因为谁都知道），不过总的来说，练习的话，模板题也够了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在数学的王国里，质数（也即素数）是数这个范围内一枚闪闪发光的重要宝石，很多公式和定理都与素数有关。这样，如何判断一个数是否是素数也是一个重要的问题，只不过这个问题的解法相当显而易见，那么我们的目光就要更多的放在对于判断素数的算法的性能的优化上了（更多的是时间复杂度）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://www.unknown9t.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数论" scheme="http://www.unknown9t.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>递推算法</title>
    <link href="http://www.unknown9t.com/2022/04/29/%E9%80%92%E6%8E%A8%E7%AE%97%E6%B3%95/"/>
    <id>http://www.unknown9t.com/2022/04/29/%E9%80%92%E6%8E%A8%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-29T13:54:40.249Z</published>
    <updated>2020-03-24T00:08:18.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>递推算法作为基础算法之一，递推的思想不难理解，难点在于多变的递推公式以及找寻递推关系时蕴含的数学的思维。由于递推算法的关键问题是得到递推关系，这种关系是一种高效的数学模型（ACM-ICPC基本算法中是这么说的），而且又灵活多变，为递推算法题目的解决带来了不少困难。所以，我认为有必要开专题对常见递推思路进行列举讲解，顺带着讲解一下递推算法的基础知识。</p><span id="more"></span><p>而且，递推关系或者说这种递推思维，不仅仅在各数学分支中发挥重要作用，它甚至延伸到了各个领域，在每个领域中都起了一定的作用。这恰恰契合了我当初高中学习编程之后的感受，也就是初步建立起了对事情的逻辑能力。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>递推，是指从已知的初始条件出发，不断得到需要的中间条件，最后求得最后结果。递推是一直向前或者向后（因为递推包含顺推和逆推）一步步走的，而且递推法利用了问题本身所具有的性质来总结递推关系，推导递推公式，问题的性质不同，就使得递推关系多种多样，有一些题就无从下手。</p><p>我们想要用递推法，先需要判断一道题应不应该用递推法来做。一般来说，可以用递推法做的题目首先要是可以把一整个大目标分解成诸多非常相似的小目标，这样可以先把目标化小，再用循环来不断求出这些小目标，即用递推式求解，可以使计算机发挥它的长处————重复大量计算。</p><p>递推法大致分为两类：</p><p>分别是</p><blockquote><p>（1）顺推法</p><p>（2）逆推法</p></blockquote><p>两者的不同大概就是推导顺序不同，这点从两种推法的名字上可见一斑。顺推法给你初始的已知条件，让你求最终结果，而逆推法给你最终结果，让你求最初的状态，也就是顺推法的逆向推导。两种方法其实没有太大本质上的区别，还是个人来看要做的那道题更适合哪种方法再用哪个。</p><p>至于递推法的过程，大概还是有一个标准的</p><ol><li>确定递推变量</li><li>建立递推关系</li><li>确定边界条件</li><li>控制递推过程</li></ol><p>找递推变量这一条一般比较容易，因为所求的结果一般都会在题目中给出来，一眼就能看到，稍微总结一下就能知道，就是递推变量可能不只是普通变量，也可能是数组之类的。</p><p>难点在于第二点，找递推关系。正如我之前的概述所说的，由于递推关系是一种高效的数学模型，要知道，任何东西和数学一扯上关系，事就变多了。在找递推关系的时候，一定要充分运用理性的逻辑思维，总结每一步的推导公式时一定要考虑到当前状态到下一状态的所有情况，而且在有些时候，运用的数学定理之类的可能已经超过了你的知识面，需要你去进行快速理解和拓展。</p><p>确定边界条件应该也不足以称为难点，一般题目中都会给出来，或者很明显一眼就可以看出来，在这里就不多说了，这是递推的基础。</p><p>最后，控制递推过程。一般是通过循环语句来控制，我们在执行递推的时候需要判断什么时候开始递推，而什么时候停止递推。</p><h2 id="几种典型递推过程"><a href="#几种典型递推过程" class="headerlink" title="几种典型递推过程"></a>几种典型递推过程</h2><p>这里列举几种典型的递推过程，可能并不全面，如果以后遇到了还会再添加。</p><h3 id="Fibonacci数列"><a href="#Fibonacci数列" class="headerlink" title="Fibonacci数列"></a>Fibonacci数列</h3><p>Fibonacci数列即斐波那契数列，相信各位的小学老师都给大家讲过吧，在大家还没有接触计算机语言的时候，斐波那契数列已经深深印在我们的灵魂里了，这也是所有递推问题中，最为大家所知的一种了。</p><pre><code>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（LeonardodaFibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从1963年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。                                                                                ————选自百度百科  \\*_*</code></pre><p>斐波那契的大致定义我想不用我多说了，那就来说一下大致的特点吧。</p><p>特点就是F(1)&#x3D;F(2)&#x3D;1,F(n)&#x3D;F(n-1)+F(n-2),(n&gt;&#x3D;3)。然后某个点的值等于上一个点的值加上上一个的上一个点的值。</p><p>而斐波那契数列的解法虽然简单，但这并不代表着这种递推已经退出了历史舞台，在一些比赛中，仍然有使用隐含斐波那契数列递推的签到题，有的甚至还比较隐晦，还有很多题型都可以用这个方法解决，而且递推的最重要的地方，就是它的思维方式，这种思维方式看着十分简单，但是仍然能够在一些地方给我们启发。</p><h3 id="Hanoi塔"><a href="#Hanoi塔" class="headerlink" title="Hanoi塔"></a>Hanoi塔</h3><p>Hanoi塔也叫汉诺塔问题，汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。（————取自百度百科）</p><p>总结出来的要求大概这样</p><ol><li>一次只能移一个圆盘；</li><li>圆盘只能在三个柱上存放；</li><li>在移动过程中，不允许大盘压小盘。</li></ol><p>汉诺塔问题一般会问到把一叠圆盘按照原顺序换到另外一个柱子上的过程，或者是问到换柱子所用到的步数。大体来说，一个新人刚刚看到汉诺塔问题好像并不会把它联想到递推过程，但是我们先来模拟一下3个盘子3根柱子的换位过程，我们把三个分别半径为1、2、3的盘子从A柱子全部按顺序换到C柱子的过程。</p><p><img src="https://www.z4a.net/images/2020/01/08/0.1.png" alt="0.1.png"></p><p>整个过程是这样的</p><p>首先，从A上面拿下来1放到C，再把2拿下来放到B（1是最上面的圆盘，2是中间的）。然后再把1放到B里的2上，形成这样子。</p><p><img src="https://www.z4a.net/images/2020/01/08/0.2.png" alt="0.2.png"></p><p>然后把3从A丢到C，再把1扔到A，2扔到C，最后1扔到C上，就把1、2、3都扔到C上了。</p><p>我们再来看一下1、2都在B上而3已经在C上的时候。这时，我们把1和2从B扔到C是不是和把1和2从A扔到B是类似的过程呢。</p><p>先别下结论，我们再来看一下如果是两个圆盘呢。我们只需要把1从A移到B，然后把2从A移到C，最后再把1从B移到C。这个过程是不是又和3个圆盘移两个的过程类似呢，我们仔细思考一下，四个圆盘扔三个是不是和3个圆盘的时候一样呢？</p><p>认真考虑之后我们发现，确实是一样的，这就找到了不同的圆盘数量，换柱子的内在联系了，这也是找到递推关系最重要的一步。</p><p>至于n个圆盘全从A换到C的搬动次数的计算公式大概是这样的，先把n-1个从A换到B，把第n个扔到C之后，再把n-1个从B到C，所以F(n)&#x3D;F(n-1)*2+1。</p><h3 id="平面分割问题"><a href="#平面分割问题" class="headerlink" title="平面分割问题"></a>平面分割问题</h3><p>这类问题有几种，大概是各种各样的线条分割一整个平面空间，有直线，有曲线，有折线，有椭圆形，有三角形。以直线为例子，题意是这样的，一整个平面，n条直线最多把整个空间分成多少块，曲线折线等等都差不多。</p><p>具体的解题思路是这样子的,当有n-1条直线的时候，平面最多被分成F(n-1)块，第n条线出现的时候，如果我们想要分块尽量多，就要让新出现的直线与之前每一条直线都有一个交点，这样就会产生n-1个交点，n-1个交点会把这第n条直线分成2条射线和n-2个线段，而每条射线和线段把现有的空间一分为二，故F(n)&#x3D;F(n-1)+n。</p><p>折线以及椭圆形的分割方式略有小小不同，希望大家可以先开动脑筋想一想，实在想不出来也没啥，去网上搜一搜，网上的博客里面都有，查一查会找到的。</p><p>图画起来太麻烦了，以后补上吧。</p><h3 id="Catalan数"><a href="#Catalan数" class="headerlink" title="Catalan数"></a>Catalan数</h3><p>Catalan数又称卡特兰数，卡塔兰数。</p><p>卡特兰数又称卡塔兰数，卡特兰数是组合数学中一个常出现在各种计数问题中的数列。以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)的名字来命名。</p><p>卡特兰数应用有很多，最先是应用在凸多边形三角划分上的。</p><p>在一个凸多边形中，通过若干条互不相交的对角线，把这个多边形划分成了若干个三角形。任务是键盘上输入凸多边形的边数n，求不同划分的方案数f（n）。比如当n&#x3D;6时，f（6）&#x3D;14。</p><p>其他应用还有，比如出栈顺序数，比如括号化……就很多，如果想要了解，也可以查查百度，甚至是查一查百度百科，毕竟我这些都是在百科上看的……(咳咳，还是遇到过一些的，比如出栈顺序……)。</p><p>至于递推公式，一共有四个，意义相同，有优有劣，我在这里列出来，以后我自己论证了优劣性再做解释。</p><pre><code>h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)*h(0) (n&gt;=2)h(n)=h(n-1)*(4*n-2)/(n+1);h(n)=C(2n,n)/(n+1) (n=0,1,2,...)h(n)=c(2n,n)-c(2n,n-1)(n=0,1,2,...)</code></pre><p>大概典型就这样，如果以后遇到了再补充。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>未完待续……</p><p>P1028 数的计算</p><p>P1192 台阶问题</p><p>P1216 [IOI1994][USACO1.5]数字三角形 Number Triangles</p><p>P1595 信封问题</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;递推算法作为基础算法之一，递推的思想不难理解，难点在于多变的递推公式以及找寻递推关系时蕴含的数学的思维。由于递推算法的关键问题是得到递推关系，这种关系是一种高效的数学模型（ACM-ICPC基本算法中是这么说的），而且又灵活多变，为递推算法题目的解决带来了不少困难。所以，我认为有必要开专题对常见递推思路进行列举讲解，顺带着讲解一下递推算法的基础知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://www.unknown9t.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="递推" scheme="http://www.unknown9t.com/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://www.unknown9t.com/2022/04/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://www.unknown9t.com/2022/04/29/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2022-04-29T13:51:36.521Z</published>
    <updated>2019-09-26T09:00:58.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>正如百度百科所说，并查集是一种树形的数据结构，并且用于处理一些不相交集合的合并及查询问题。一般地来说，并查集由两个部分组成，一个是查找要操作的两个集合是否属于同一个，另一个则是进行这两个集合合并的过程。</p><span id="more"></span><p>并查集中，每一个集合用一个标识来表示，一般来说，大家都会选择这棵树的根作为这个标识。我们根据每棵树的标记来判断某些节点是否在同一个集合中，也就是是否属于同一棵树。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>就我目前的理解来说，并查集本身其实只包含三个部分：初始化，查找与合并。而其中查找与合并两个部分，有可能边并边查，也同样有可能先并再查，这都无可厚非，并且不影响并查集本身的工作。在查找和合并这两个步骤又分别包含了两种优化方式，也就是我们常说的路径压缩和按秩合并。</p><h2 id="并查集本身"><a href="#并查集本身" class="headerlink" title="并查集本身"></a>并查集本身</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>并查集是一种树形的数据结构。我们要运用并查集求解问题，就需要构建树。我们首先把每个节点的标记初始化为它自身，也就是说每个节点自成一棵树，这个节点既是自己的父亲（f数组记录），也是自己的祖宗（find函数查找）。</p><p>用代码实现就是如下效果</p><pre><code>   for(int i=1;i&lt;=n;i++) //n为节点数&#123;    f[i]=i;//f数组记录节点的父节点&#125;</code></pre><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>我们可能需要对某两个节点进行判断，判断他们之间是否存在某种关系（比如是否是敌人或者是否是朋友）。此时我们只需找到两个节点的祖先（find函数返回的值）并且判断两个节点的祖先是否相等。</p><p>这里就出现了一个问题，我们每次寻找祖先的时候都需要不断上访节点的父亲，假如某个辈分极低的节点被反复查询，该极长的路径被反复遍历。抑或是该辈分极低的节点被查询过，而在它上面的节点又被查询，就会导致某一条路被反复遍历，无疑浪费了时间。这里就引出了第一种优化方式：路径压缩。当然我们在此只是提一句，下面并查集优化的时候再详细讲解。</p><p>这里的查找函数写法有两种，一种是递归写法，一种是非递归写法，我都写在下面，仅供参考。</p><p>这里是递归写法：</p><pre><code>int find(int r)&#123;    if(f[r]==r)    &#123;        return r;    &#125;    else    &#123;        return find(f[r]);    &#125;&#125;</code></pre><p>这里是非递归写法：</p><pre><code>int find(int r)&#123;    while(f[r]==r)    &#123;        r=f[r];    &#125;    return r;&#125;</code></pre><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>并查集的过程中，既需要查找，也需要合并。当两个节点当前所处集合不同，但实际上应该处于同一集合时，我们需要将这两个集合合并。当然，我们并不能只是合并这两个点，而是应该查找它们的祖先节点，并且合并两个祖先节点，选择一个祖先节点为两个集合共同的祖先节点（也即代表节点）。</p><p>我们只需要把其中一个祖先节点的父亲节点赋值成另外一个祖先节点即可完成该操作。</p><pre><code>if(find(a)!=find(b))&#123;    f[find(a)]=find(b);&#125;</code></pre><p>这里可以提前把a节点和b节点的祖先赋给两个变量来缩减代码量。</p><p>在这里，又可以引出另一个优化的可能，那就是在合并的时候，可能会出现一大一小两棵树（也可以称作一大一小两个集合），若把大树并到了小树上，就会导致最长的路径越来越长以致于查询的时候需要遍历的节点不断增多。由此引出了按秩合并的思路，我们总寻找小树，并且把小树并到大树上。这里也暂作引出，下面来解释优化操作。</p><h2 id="并查集优化"><a href="#并查集优化" class="headerlink" title="并查集优化"></a>并查集优化</h2><p>我们很明显可以看出来，并查集本身的时间消耗还是比较大的，并且存在着大量的重复遍历操作，下面我来解释两种常见的优化方式。单独用按秩合并可以将并查集的时间复杂度降低到O(nlogn)，既n乘以2为底n的对数，单独使用路径压缩则会提升查找效率。而两种一起用甚至可以将每一步查找、合并的时间复杂度降低至O(α(n))，其中α(n)名为反阿克曼函数。阿克曼函数极剧增长而反阿克曼函数几乎不增长，我们可以将优化后的并查集时间复杂度看作O(n)，n为操作数。</p><p>至于为什么会被优化这么多，以至于达到了O(n)的线性增长关系，相信我解释完这两种优化方式之后你心中会有一点答案。</p><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>首先，路径压缩，正如我上面查找步骤讲解中所说，在某一条极长路径中，一些路径会被反复遍历，从而造成重复冗余。所以，我们在查找的时候，对于每一个节点，改变它们的路径，让他们直接连接在根节点（标识节点）也即祖先节点下，使他们与祖先节点成为父子关系。这样，在再次查询这些点的时候，仅需最多两次查找即可查询到它们的祖先节点。</p><pre><code>int find(int r)&#123;    if(f[r]==r)    &#123;        return r;    &#125;    else    &#123;        return f[r]=find(f[r]);    &#125;&#125;</code></pre><p>这是一种递归形式，在递归的过程中就把祖先节点赋值成了这些过程中包含的节点的父亲。</p><h3 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h3><p>然后，按秩合并，也正如我上面合并步骤讲解中所说，大树合并到小树上的时候会造成不小的麻烦，所以我们在合并之前判断一下两个集合的大小关系，并且把小树合并到大树上。我们将这个大小关系规定成口中的“秩”。这个“秩”既可以代表树的高度，也可以代表集合内节点的数量。但是在这里要注意了！！！只有在没有使用路径压缩的时候才可以用“秩”代表树的高度，因为一旦路径压缩，所有的子节点全部与祖先节点直连，树的高度都将被划成2。故一般在同时使用两种优化方式时，通常直接把秩看作了节点数量。</p><pre><code>int azhb(int l,int r)&#123;    if(jds[find(l)]&lt;jds[find(r)])    &#123;        f[find(l)]=find(r);        jds[find(r)]+=jds[find(l)];    &#125;    else    &#123;        f[find(r)]=find(l);        jds[find(l)]+=jds[find(r)];    &#125;&#125;</code></pre><p>在这里，我规定传进来的参数为两个原始节点，然而这样会比较麻烦，所以我一般在用到按秩合并的时候都会直接将两个祖先节点传进来，以便于直接使用jds（节点数）这个数组。ps：函数名就是按秩合并的缩写，不要吐槽这个……</p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>我们降低问题的复杂程度，假设只需要进行n次操作，所有的查找都在合并操作之后出现。对于每个需要访问的节点x，在其第一次被查找的时候就会被路径压缩优化成与祖先节点直连，当再次访问x节点的时候，只需要最多两次最少一次的访问。而按秩合并则会一直保证不会出现高度大于2的树出现。两种优化方式一起出现，会直接将并查集的时间复杂度降低到线性增长关系。</p><p>其中反阿克曼函数有关的知识，有兴趣的话可以自行查找理解学习，我暂时没太大兴趣，也许之后会深入学习一下。</p><h2 id="引例讲解全过程"><a href="#引例讲解全过程" class="headerlink" title="引例讲解全过程"></a>引例讲解全过程</h2><p><img src="https://www.z4a.net/images/2019/09/06/1.1.jpg" alt="1.1.jpg"></p><p>来看这个例子，实际上这个输入输出样例是洛谷P3367 并查集的一道模板题，我把它拿下来当作例子来讲解一下。</p><p>首先看输入，4个点，7个操作。每个操作的第一个数字，1代表着合并操作，2代表着查询操作。</p><p>一开始对这四个点进行初始化：</p><p><img src="https://www.z4a.net/images/2019/09/06/1.2.jpg" alt="1.2.jpg"></p><p>这四个点，每一个都是独立的一个集合。</p><p>然后我们开始进行操作，第一条操作查找，我们就直接用find函数寻找祖先，发现都是它们本身，判断出来不在同一集合，肯定输出N。</p><p>第二条操作和第四条操作分别合并1 2以及3 4，合并之后的效果就是这样。</p><p><img src="https://www.z4a.net/images/2019/09/06/1.3.jpg" alt="1.3.jpg"></p><p>而在此时，操作要求把2和3合并，我们查询2的祖先发现是1，查询3的祖先，发现就是3本身，故合并1与3。</p><p><img src="https://www.z4a.net/images/2019/09/07/1.4.jpg" alt="1.4.jpg"></p><p>如果加入了路径压缩，在下一次操作也就是最后一次操作的时候，需要查询1和4，此时会在查询的过程中，将4直连到1的下面。</p><p><img src="https://www.z4a.net/images/2019/09/07/1.5.jpg" alt="1.5.jpg"></p><p>而由于这个例子不算复杂，体现不出来按秩合并以及路径压缩的真意。我来稍微让这个例子变得复杂一些，再分析一下。</p><p><img src="https://www.z4a.net/images/2019/09/07/1.6.jpg" alt="1.6.jpg"></p><p>我们在4节点的下面再连接一个5节点</p><p>如果我们不考虑按秩合并，只进行路径压缩，把3节点并到1上面。</p><p><img src="https://www.z4a.net/images/2019/09/07/1.7.jpg" alt="1.7.jpg"></p><p>这样我们在下次查询5的时候，进行路径压缩，需要转移4和5两次。这样看来，把1并给3的时候也会转移两次，好像没什么太大的时间优势。但是当长链够长的时候，按秩合并的时间优势就会体现出来，并且把时间复杂度大幅优化。</p><p>在我出的这个例子中，貌似把“秩”当作树的高度也可以，但是试想一下经过路径压缩之后，每个集合都变成了一个根节点下面连着数个节点的多叉树，所以路径压缩之后的并查集，“秩”还是当作节点数好一些。</p><p>下面我来贴出我模板的代码</p><pre><code>#include&lt;stdio.h&gt;int f[10005];int jds[10005]=&#123;0&#125;;int find(int r)&#123;    if(f[r]==r)    &#123;        return r;    &#125;    else    &#123;        return f[r]=find(f[r]);    &#125;&#125;int azhb(int l,int r)&#123;    if(jds[l]&lt;jds[r])    &#123;        f[l]=r;        jds[r]+=jds[l];    &#125;    else    &#123;        f[r]=l;        jds[l]+=jds[r];    &#125;&#125;int main()&#123;    int n,m;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    int a,b,c;    int fb,fc;    for(int i=1;i&lt;=n;i++)    &#123;        f[i]=i;    &#125;    for(int i=1;i&lt;=m;i++)    &#123;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        fb=find(b);        fc=find(c);        if(a==1)        &#123;            if(fb!=fc)            &#123;                azhb(fb,fc);            &#125;        &#125;        else        &#123;            if(fb==fc)            &#123;                printf(&quot;Y\n&quot;);            &#125;                else            &#123;                printf(&quot;N\n&quot;);            &#125;        &#125;    &#125;    return 0;&#125;</code></pre><p>别吐槽我的变量名和函数名＞﹏＜</p><h2 id="多关系并查集"><a href="#多关系并查集" class="headerlink" title="多关系并查集"></a>多关系并查集</h2><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="洛谷-P1551-亲戚"><a href="#洛谷-P1551-亲戚" class="headerlink" title="洛谷 P1551 亲戚"></a>洛谷 P1551 亲戚</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P1551" title="https://www.luogu.org/problem/P1551">https://www.luogu.org/problem/P1551</a></p><p><img src="https://www.z4a.net/images/2019/09/07/2.1.jpg" alt="2.1.jpg"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就是一个裸的并查集。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;int f[10005];int jds[10005];int a,b;int fa,fb;int find(int r)&#123;    if(f[r]==r)    &#123;        return r;    &#125;    else    &#123;        return f[r]=find(f[r]);    &#125;&#125;int azhb(int l,int r)&#123;    if(jds[l]&lt;jds[r])    &#123;        f[fa]=fb;        jds[r]+=jds[l];    &#125;    else    &#123;        f[fb]=fa;        jds[l]+=jds[r];    &#125;&#125;int main()&#123;    int n,m,p;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p);    for(int i=1;i&lt;=n;i++)    &#123;        f[i]=i;    &#125;    for(int i=1;i&lt;=m;i++)    &#123;        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        fa=find(a);        fb=find(b);        if(fa!=fb)        &#123;            azhb(fa,fb);        &#125;    &#125;    for(int i=1;i&lt;=p;i++)    &#123;        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        if(find(a)==find(b))        &#123;            printf(&quot;Yes\n&quot;);        &#125;        else        &#123;            printf(&quot;No\n&quot;);        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="洛谷-P2820-局域网"><a href="#洛谷-P2820-局域网" class="headerlink" title="洛谷 P2820 局域网"></a>洛谷 P2820 局域网</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P2820" title="https://www.luogu.org/problem/P2820">https://www.luogu.org/problem/P2820</a></p><p><img src="https://www.z4a.net/images/2019/09/07/3.1.jpg" alt="3.1.jpg"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这是一个最小生成树的题目，几乎可以算是裸的最小生成树，有关最小生成树的算法在之后我会开专题讲解。这里我来简单阐述一下这道题我用到的，我这道题用到了克鲁斯卡尔，大概思路就是，先把图中所有路径从小到大排序，然后逐个进行判断，若两个点不在同一集合则合并，若在同一集合则往下过，直到图中所有点都已经进入点集。</p><p>简单来说，就是一种排序算法先对数据进行处理，然后再用并查集最后求得最小值。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;int v[10005]=&#123;0&#125;;int f[10005];int jds[10005];struct a&#123;    int begin;    int end;    int w;&#125;a[10005];int find(int r)&#123;    if(f[r]==r)    &#123;        return r;    &#125;    else    &#123;        return f[r]=find(f[r]);    &#125;&#125;int azhb(int l,int r)&#123;    if(jds[l]&lt;jds[r])    &#123;        f[l]=r;        jds[r]+=jds[l];    &#125;     else    &#123;        f[r]=l;        jds[l]+=jds[r];    &#125;&#125;int main()&#123;    int n,k;    int t;    int fa,fb;    int sum=0;    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    for(int i=1;i&lt;=k;i++)    &#123;        scanf(&quot;%d%d%d&quot;,&amp;a[i].begin,&amp;a[i].end,&amp;a[i].w);    &#125;    for(int i=1;i&lt;=k;i++)    &#123;        f[i]=i;        jds[i]=1;    &#125;    for(int i=k;i&gt;=1;i--)    &#123;        for(int j=1;j&lt;=i-1;j++)        &#123;            if(a[j].w&gt;a[j+1].w)            &#123;                t=a[j].w;                a[j].w=a[j+1].w;                a[j+1].w=t;                t=a[j].begin;                a[j].begin=a[j+1].begin;                a[j+1].begin=t;                t=a[j].end;                a[j].end=a[j+1].end;                a[j+1].end=t;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=k;i++)    &#123;        fa=find(a[i].begin);        fb=find(a[i].end);        if(fa!=fb)        &#123;            azhb(fa,fb);            v[i]=1;        &#125;    &#125;    for(int i=1;i&lt;=k;i++)    &#123;        if(v[i]==0)        &#123;            sum+=a[i].w;        &#125;    &#125;    printf(&quot;%d&quot;,sum);    return 0;&#125;</code></pre><h2 id="洛谷-P3144-USACO16OPEN-关闭农场Closing-the-Farm-Silver"><a href="#洛谷-P3144-USACO16OPEN-关闭农场Closing-the-Farm-Silver" class="headerlink" title="洛谷 P3144 [USACO16OPEN]关闭农场Closing the Farm_Silver"></a>洛谷 P3144 [USACO16OPEN]关闭农场Closing the Farm_Silver</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P3144" title="https://www.luogu.org/problem/P3144">https://www.luogu.org/problem/P3144</a></p><p><img src="https://www.z4a.net/images/2019/09/07/4.1.jpg" alt="4.1.jpg"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这个题可以倒着想，逐渐加边进去。因为并查集只能合并以及查询，也就是不断加边进图，而不能从图中删除边，所以很自然的想到倒着加边进去然后判断一共有几个集合，时间复杂度也不会很高。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;int dian[3005]=&#123;0&#125;;int sc[3005];int f[3005];int v[3005][3005]=&#123;0&#125;;int jl[3005];int jds[3005];int jhs;int a,b;int find(int r)&#123;    if(f[r]==r)    &#123;        return r;    &#125;    else    &#123;        return f[r]=find(f[r]);    &#125;&#125;int azhb(int l,int r)&#123;    if(jds[l]&lt;jds[r])    &#123;        f[l]=r;        jds[r]+=jds[l];    &#125;    else    &#123;        f[r]=l;        jds[l]+=jds[r];    &#125;&#125;int main()&#123;    int n,m;    jhs=0;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=m;i++)    &#123;        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        v[a][b]=1;        v[b][a]=1;    &#125;    for(int i=1;i&lt;=n;i++)    &#123;        f[i]=i;    &#125;    for(int i=n;i&gt;=1;i--)    &#123;        scanf(&quot;%d&quot;,&amp;jl[i]);    &#125;    sc[1]=1;    dian[jl[1]]=1;    for(int i=1;i&lt;=n;i++)    &#123;        if(v[jl[1]][i]==1)        &#123;            if(dian[i]==1)            &#123;                azhb(find(jl[1]),find(i));            &#125;        &#125;    &#125;    for(int i=2;i&lt;=n;i++)    &#123;        jhs=0;        for(int j=1;j&lt;=n;j++)        &#123;            if(v[jl[i]][j]==1)            &#123;                if(dian[j]==1)                &#123;                    azhb(find(jl[i]),find(j));                &#125;            &#125;        &#125;        dian[jl[i]]=1;        for(int j=1;j&lt;=n;j++)        &#123;            if(dian[j]==1&amp;&amp;f[j]==j)            &#123;                jhs++;            &#125;        &#125;        if(jhs&gt;1)        &#123;            sc[i]=0;        &#125;        else        &#123;            sc[i]=1;        &#125;    &#125;    for(int i=n;i&gt;=1;i--)    &#123;        if(sc[i]==1)        &#123;            printf(&quot;YES\n&quot;);        &#125;        else        &#123;            printf(&quot;NO\n&quot;);        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="洛谷-P3958-奶酪"><a href="#洛谷-P3958-奶酪" class="headerlink" title="洛谷 P3958 奶酪"></a>洛谷 P3958 奶酪</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P3958" title="https://www.luogu.org/problem/P3958">https://www.luogu.org/problem/P3958</a></p><p><img src="https://www.z4a.net/images/2019/09/07/6.1.jpg" alt="6.1.jpg"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这道题我把奶酪的上表面空气与下表面空气看作了两个横跨长宽的大集合，然后当有可以通向下面的奶酪洞存在时，我便将下表面空气的大集合和该奶酪洞合并，上表面空气也是一样的操作，最后查询上表面空气和下表面空气是否存在于一个集合中即可完成。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;#include&lt;math.h&gt;int f[10005];int jds[10005];int n,h,r;struct a&#123;    long long x;    long long y;    long long z;&#125;a[1005];int find(int r)&#123;    if(f[r]==r)    &#123;        return r;    &#125;    else    &#123;        return f[r]=find(f[r]);    &#125;&#125;long long pf(long long q)&#123;    return q*q;&#125;void azhb(int l,int r)&#123;    if(jds[l]&lt;jds[r])    &#123;        f[l]=r;        jds[r]+=jds[l];    &#125;    else    &#123;        f[r]=l;        jds[l]+=jds[r];    &#125;&#125;int main()&#123;    int t;    scanf(&quot;%d&quot;,&amp;t);    for(int i=1;i&lt;=t;i++)    &#123;        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;h,&amp;r);        for(int j=1;j&lt;=n;j++)        &#123;            f[j]=j;            jds[j]=0;        &#125;        f[2000]=2000;        jds[2000]=0;        f[3000]=3000;        jds[3000]=0;        for(int j=1;j&lt;=n;j++)        &#123;            scanf(&quot;%lld%lld%lld&quot;,&amp;a[j].x,&amp;a[j].y,&amp;a[j].z);        &#125;        for(int j=1;j&lt;=n;j++)        &#123;            for(int k=1;k&lt;=n;k++)            &#123;                if(sqrt(pf(a[j].x-a[k].x)+pf(a[j].y-a[k].y)+pf(a[j].z-a[k].z))&lt;=(r*2))                &#123;                    azhb(find(j),find(k));                &#125;            &#125;            if((a[j].z)&lt;=r)            &#123;                azhb(find(j),find(2000));            &#125;            if((a[j].z)&gt;=h-r)            &#123;                azhb(find(j),find(3000));            &#125;        &#125;        if(find(2000)==find(3000))        &#123;            printf(&quot;Yes\n&quot;);        &#125;        else        &#123;            printf(&quot;No\n&quot;);        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="洛谷-P2078-朋友"><a href="#洛谷-P2078-朋友" class="headerlink" title="洛谷 P2078 朋友"></a>洛谷 P2078 朋友</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P2078" title="https://www.luogu.org/problem/P2078">https://www.luogu.org/problem/P2078</a></p><p><img src="https://www.z4a.net/images/2019/09/07/7.1.jpg" alt="7.1.jpg"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>这道题就是两个并查集。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;#include&lt;math.h&gt;int f1[10005];int f2[10005];int jds1[10005];int jds2[10005]; int jdz(int r)&#123;    if(r&lt;0)    &#123;        return -r;    &#125;    else    &#123;        return r;    &#125;&#125;int min(int l,int r)&#123;    if(l&lt;r)    &#123;        return l;    &#125;    else    &#123;        return r;    &#125;&#125;int find1(int r)&#123;    if(f1[r]==r)    &#123;        return r;    &#125;    else    &#123;        return f1[r]=find1(f1[r]);    &#125;&#125;int azhb1(int l,int r)&#123;    if(jds1[l]&lt;jds1[r])    &#123;        f1[l]=r;        jds1[r]+=jds1[l];    &#125;    else    &#123;        f1[r]=l;        jds1[l]+=jds1[r];    &#125;&#125;int find2(int r)&#123;    if(f2[r]==r)    &#123;        return r;    &#125;    else    &#123;        return f2[r]=find2(f2[r]);    &#125;&#125;int azhb2(int l,int r)&#123;    if(jds2[l]&lt;jds2[r])    &#123;        f2[l]=r;        jds2[r]+=jds2[l];    &#125;    else    &#123;        f2[r]=l;        jds2[l]+=jds2[r];    &#125;&#125;int main()&#123;    int n,m,p,q;    int fa,fb;    int a,b;    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;p,&amp;q);    for(int i=1;i&lt;=n;i++)    &#123;        f1[i]=i;        jds1[i]=1;    &#125;    for(int i=1;i&lt;=m;i++)    &#123;        f2[i]=i;        jds2[i]=1;    &#125;    for(int i=1;i&lt;=p;i++)    &#123;        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        fa=find1(a);        fb=find1(b);        if(fa!=fb)        &#123;            azhb1(fa,fb);        &#125;    &#125;    for(int i=1;i&lt;=q;i++)    &#123;        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        fa=find2(jdz(a));        fb=find2(jdz(b));        if(fa!=fb)        &#123;            azhb2(fa,fb);        &#125;    &#125;    printf(&quot;%d&quot;,min(jds1[find1(1)],jds2[find2(1)]));    return 0;&#125;</code></pre><h1 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;正如百度百科所说，并查集是一种树形的数据结构，并且用于处理一些不相交集合的合并及查询问题。一般地来说，并查集由两个部分组成，一个是查找要操作的两个集合是否属于同一个，另一个则是进行这两个集合合并的过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://www.unknown9t.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://www.unknown9t.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>bfs习题讲解</title>
    <link href="http://www.unknown9t.com/2022/04/29/bfs%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3/"/>
    <id>http://www.unknown9t.com/2022/04/29/bfs%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3/</id>
    <published>2022-04-29T13:49:21.752Z</published>
    <updated>2019-08-22T13:11:30.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在我看来，每种算法都由两个部分组成，一部分是思想，另外一部分就是实现能力，二者缺一不可。缺少思想，算法就无法站住，或者可以说固定的模板无法和灵活的题目相联系。缺少实现能力，算法就成了空中楼阁，你想到的思路再清晰再高明，打不出来终究是心有余力不足。</p><span id="more"></span><p>在这篇博客中我将根据具体例题讲解部分bfs思路，正如上面所说，思想和实现能力是相辅相成的，我在这里理清了思路，还需要进行一个系列题目的练习，才能说把思路巩固了。如果有能力再进行高级的练习以及对于题目变形的解答。我希望在讲解的过程中也可以教学相长，如有错漏还请不吝赐教。</p><p>另外我有一些地方用到了结构体，不太明白的同学可以查一查，其实不难理解。</p><h1 id="正文（例题）"><a href="#正文（例题）" class="headerlink" title="正文（例题）"></a>正文（例题）</h1><h2 id="洛谷-P1746-离开中山路"><a href="#洛谷-P1746-离开中山路" class="headerlink" title="洛谷 P1746 离开中山路"></a>洛谷 P1746 离开中山路</h2><p>一个很简单的地图bfs</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P1746" title="https://www.luogu.org/problem/P1746">https://www.luogu.org/problem/P1746</a></p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-1.1.jpg" alt="bfs-1.1.jpg"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一个字符型数组录入整张地图，然后从起始点出发。</p><p>我们以题目所给样例作解答。</p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-1.2.jpg" alt="bfs-1.2.jpg"></p><p>按照样例我们来直观地画一张图：</p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-1.3.jpg" alt="bfs-1.3.jpg"></p><p>此时我们建立一个队列数组，用来存放需要入队出队的位置，也就是被搜索到的位置，bfs不像dfs那样直接在dfs函数中调用，所以需要一个数组来决定它们执行搜索的先后顺序，我们也同样把这个队列数组画出来。</p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-1.4.jpg" alt="bfs-1.4.jpg"></p><p>实现模拟队列的时候，与栈不同的是，队列需要两个变量，一个名叫head，一个叫tail，分别代表着队列的队头和队尾，只有队头和队尾中间才是队列的范围，当有数据需要入队，就令队尾自加，然后把数据加入，当有数据需要出队，则使队头自加即可。</p><p>那有的人就会说了，这样做数组的空间很浪费，所以才会出现了循环队列以及用链表实现的方法，这些暂时不会用到，所以仅在此提及一下。</p><p>接下来，我们来讲解这道题具体的bfs过程。</p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-1.5.jpg" alt="bfs-1.5.jpg"></p><p>我们先把起始点[1][1]入队，此时的head和tail初始化都赋值为1。</p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-1.6.jpg" alt="bfs-1.6.jpg"></p><p>此时开始只要head&lt;&#x3D;tail就不断循环调用bfs函数，从队列中的队头元素开始，对[1][1]这个点的四个方向进行枚举判断，发现仅右侧即[1][2]这个位置可以入队，故将该点入队。</p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-1.7.jpg" alt="bfs-1.7.jpg"></p><p>随后此次bfs过程结束，我们把这次bfs搜索过的点出队。</p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-1.8.jpg" alt="bfs-1.8.jpg"></p><p>按照如此的过程，把[2][2]这个位置入队。</p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-1.10.jpg" alt="bfs-1.10.jpg"></p><p>然后到最后，按照我的代码思路，最后会是这样。</p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-1.11.jpg" alt="bfs-1.11.jpg"></p><p>因为在执行[3][2]这个bfs的时候，向四周搜索会直接发现终点[3][3]，按照我的代码思路，此时应该将某个标记设置成1然后直接跳出，之后的过程由于某标记已经置1所以不用再执行了。而有些查找可能路径的题目则或许不用半路跳出，则只需等head&gt;tail之后自动跳出循环即可。</p><p>另外在最终我们需要找出终点距起点的最短距离，那么我们只需要在每个点记录当前点的距离，然后对于每个由该点引出的，先前未被搜索过的点，只需将该距离加1即可。</p><p>如图。</p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-1.12.jpg" alt="bfs-1.12.jpg"></p><p>当然在搜索过程中，已经搜索过的位置就不需要再次搜索了，因为在bfs过程中，某一个位置的最近到达所需距离就是它第一次被搜索到的时候的距离，多次搜索替换这个距离的话有可能造成错误，也浪费时间。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;int mapv[1005][1005]=&#123;0&#125;;char map[1005][1005];struct que&#123;    int x;    int y;    int sec;&#125;que[2000005];int n;int pd;int head,tail;int x1,y1,x2,y2;int xa[5]=&#123;-1,0,1,0&#125;;int ya[5]=&#123;0,-1,0,1&#125;;void bfs(int q)&#123;    for(int i=0;i&lt;=3;i++)    &#123;        if((que[q].x+xa[i])&gt;=0&amp;&amp;(que[q].x+xa[i])&lt;=n-1&amp;&amp;(que[q].y+ya[i])&gt;=0&amp;&amp;(que[q].+ya[i])&lt;=n-1)        &#123;            if((que[q].x+xa[i])==x2-1&amp;&amp;(que[q].y+ya[i])==y2-1)            &#123;                pd=1;                printf(&quot;%d\n&quot;,que[q].sec+1);                return;            &#125;            if(mapv[que[q].x+xa[i]][que[q].y+ya[i]]==0&amp;&amp;map[que[q].x+xa[i]][que[q].y+ya[i]]==&#39;0&#39;)            &#123;                tail++;                que[tail].x=que[q].x+xa[i];                que[tail].y=que[q].y+ya[i];                que[tail].sec=que[q].sec+1;                mapv[que[q].x+xa[i]][que[q].y+ya[i]]=1;            &#125;        &#125;    &#125;&#125;int main()&#123;    head=1,tail=1;    pd=0;    scanf(&quot;%d&quot;,&amp;n);    for(int i=0;i&lt;=n-1;i++)    &#123;        scanf(&quot;%s&quot;,map[i]);    &#125;    scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);    que[1].x=x1-1;    que[1].y=y1-1;    que[1].sec=0;    if(x1==x2&amp;&amp;y1==y2)    &#123;        printf(&quot;0&quot;);        return 0;    &#125;    while(head&lt;=tail)    &#123;        bfs(head);        head++;        if(pd==1)        &#123;            break;        &#125;    &#125;    return 0;&#125; </code></pre><h2 id="洛谷-P1443-马的遍历"><a href="#洛谷-P1443-马的遍历" class="headerlink" title="洛谷 P1443 马的遍历"></a>洛谷 P1443 马的遍历</h2><p>对整张地图所有点进行搜索，找最短能到达的距离。</p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P1443" title="https://www.luogu.org/problem/P1443">https://www.luogu.org/problem/P1443</a></p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-2.1.jpg" alt="bfs-2.1.jpg"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>棋盘上马走日，所以对于一般上下左右的四个点变成了另外的点。</p><p>有些点是走不到的，输出格式要求不能到达则输出-1，我们可以把记录整张地图最少步数的二维数组初始化为-1。另外题目要求左对齐，宽5格。</p><p>与普通的题目类似，只需不断进行bfs即可。</p><p>下面以题目样例为例讲解过程。</p><p>起始点是[1][1]，我们首先将该点入队，并且进行基本的初始化。</p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-2.2.jpg" alt="bfs-2.2.jpg"></p><p>随后，对于该点可跳到的点进行枚举判断，随后tail自加两次并且分别入栈[2][3] [3][2]，[1][1]出队，head自加。</p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-2.4.jpg" alt="bfs-2.4.jpg"></p><p>我们可以看到这两个新入队的点，步数都为1，都是由0+1得来的。</p><p>随后对队头元素([2][3])可跳到的点进行枚举判断。</p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-2.5.jpg" alt="bfs-2.5.jpg"></p><p>[2][3]可以跳到[1][1]以及[3][1]这两个地图中的位置，但是由于[1][1]已经走过了，故不再入队，只将[3][1]入队，并且head自加，代表[2][3]这个点的bfs已经完成。</p><p>最后整个队列应该是这样子的。</p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-2.6.jpg" alt="bfs-2.6.jpg"></p><p>随后head自加，再一次的循环中，head比tail大了，故能走到的点已经走完了，跳出了循环，地图上也已经打好了标记，没有走到的按照初始值是-1，这样就满足了题目的条件。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;int a[405][405];int n,m;int l=1;int r=1;int sx,sy;int xa[10]=&#123;1,2,2,1,-1,-2,-2,-1&#125;;int ya[10]=&#123;2,1,-1,-2,2,1,-1,-2&#125;;struct b&#123;    int x1;    int y1;    int bu;&#125;b[40001];void bfs(int x,int y,int bs)&#123;    for(int t=0;t&lt;=7;t++)    &#123;        if(a[x+xa[t]][y+ya[t]]==-1&amp;&amp;x+xa[t]&gt;0&amp;&amp;x+xa[t]&lt;n+1&amp;&amp;y+ya[t]&gt;0&amp;&amp;y+ya[t]&lt;m+1)        &#123;            r++;            b[r].x1=x+xa[t];            b[r].y1=y+ya[t];            b[r].bu=bs+1;            a[x+xa[t]][y+ya[t]]=bs+1;        &#125;    &#125;&#125;int main()&#123;    int i,j;    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;sx,&amp;sy);    for(i=1;i&lt;=n;i++)    &#123;        for(j=1;j&lt;=m;j++)        &#123;            a[i][j]=-1;        &#125;    &#125;    b[1].x1=sx;    b[1].y1=sy;    b[1].bu=0;    a[sx][sy]=0;    while(l&lt;=r)    &#123;        bfs(b[l].x1,b[l].y1,b[l].bu);        l++;    &#125;    for(i=1;i&lt;=n;i++)    &#123;        for(j=1;j&lt;=m;j++)        &#123;            printf(&quot;%-5d&quot;,a[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125;</code></pre><h2 id="洛谷-P1747-好奇怪的游戏"><a href="#洛谷-P1747-好奇怪的游戏" class="headerlink" title="洛谷 P1747 好奇怪的游戏"></a>洛谷 P1747 好奇怪的游戏</h2><p>就是两遍bfs，并且一个点的可选点位变成了八个。</p><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P1747" title="https://www.luogu.org/problem/P1747">https://www.luogu.org/problem/P1747</a></p><p><img src="https://www.z4a.net/images/2019/08/13/bfs-3.1.jpg" alt="bfs-3.1.jpg"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这题当时做的时候没有太仔细想，我的做法就是一遍bfs之后把该初始化的全部初始化再进行一遍bfs。</p><p>具体bfs的实施过程也就是一个八个可能点位的普通地图bfs，就不在这里多说的，过程的话大概也都能明白。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;int mapw[30][30]=&#123;0&#125;;int xa[15]=&#123;-2,-2,-1,1,2,2,2,2,1,-1,-2,-2&#125;;int ya[15]=&#123;1,2,2,2,2,1,-1,-2,-2,-2,-2,-1&#125;;int head,tail;int pd;struct que&#123;    int x1;    int y1;    int leap1;&#125;que[4005];void bfs(int q)&#123;    for(int i=0;i&lt;=11;i++)    &#123;        if(que[q].x1+xa[i]==1&amp;&amp;que[q].y1+ya[i]==1)        &#123;            pd=1;            printf(&quot;%d\n&quot;,que[q].leap1+1);            return;        &#125;        if((que[q].x1+xa[i])&gt;=1&amp;&amp;(que[q].x1+xa[i])&lt;=20&amp;&amp;(que[q].y1+ya[i])&gt;=1&amp;&amp;(que[q].y1+ya[i])&lt;=20)        &#123;            if(mapw[que[q].x1+xa[i]][que[q].y1+ya[i]]==0)            &#123;                mapw[que[q].x1+xa[i]][que[q].y1+ya[i]]=1;                tail++;                que[tail].x1=que[q].x1+xa[i];                que[tail].y1=que[q].y1+ya[i];                que[tail].leap1=que[q].leap1+1;            &#125;        &#125;    &#125;&#125;int main()&#123;    int x[5];    int y[5];    scanf(&quot;%d%d%d%d&quot;,&amp;x[1],&amp;y[1],&amp;x[2],&amp;y[2]);    for(int t=1;t&lt;=2;t++)    &#123;        memset(mapw,0,sizeof(mapw));        head=1;        tail=1;        pd=0;        que[1].x1=x[t];        que[1].y1=y[t];        que[1].leap1=0;        if(x[t]==1&amp;&amp;y[t]==1)        &#123;            printf(&quot;0\n&quot;);            continue;        &#125;        while(head&lt;=tail)        &#123;            bfs(head);            head++;            if(pd==1)            &#123;                break;            &#125;        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="洛谷-P1135-奇怪的电梯"><a href="#洛谷-P1135-奇怪的电梯" class="headerlink" title="洛谷 P1135 奇怪的电梯"></a>洛谷 P1135 奇怪的电梯</h2><p>这感觉上也算个地图型bfs了吧，我第一个打的bfs，思路可能有点乱，然后当时脑子也不咋清楚。</p><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P1135" title="https://www.luogu.org/problem/P1135">https://www.luogu.org/problem/P1135</a></p><p><img src="https://www.z4a.net/images/2019/08/14/bfs-4.1.jpg" alt="bfs-4.1.jpg"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>就类地图型bfs，不同的是没有明显地图，然后每个点有两个选择。</p><p>另外和地图一样，这题目也是有边界的，需要谨慎处理这个边界的情况。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;int d[100005];   //bfs的层数组（队列） int cs[100005]=&#123;0&#125;;//第几次按电梯到达第i层 int c[205];//第i层所记录的数字 int q[205]=&#123;0&#125;;int gb[5]=&#123;-1,1&#125;;int head,tail;int a,b,n;int pd=0;void bfs(int ceng)&#123;    if(q[d[ceng]]==0)    &#123;        q[d[ceng]]=1;        for(int i=0;i&lt;=1;i++)        &#123;            if(d[ceng]+gb[i]*c[d[ceng]]&lt;=n&amp;&amp;d[ceng]+gb[i]*c[d[ceng]]&gt;=1)            &#123;                tail++;                d[tail]=d[ceng]+gb[i]*c[d[ceng]];                cs[tail]=cs[ceng]+1;                if(d[tail]==b)                &#123;                    pd=1;                    return;                &#125;            &#125;        &#125;    &#125;&#125; int main()&#123;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;a,&amp;b);    for(int i=1;i&lt;=n;i++)    &#123;        scanf(&quot;%d&quot;,&amp;c[i]);    &#125;    head=1;    tail=1;    q[a]=0;    d[1]=a;    cs[a]=0;    if(a==b)    &#123;        printf(&quot;0&quot;);        return 0;    &#125;    while(head&lt;=tail)    &#123;        bfs(head);        head++;        if(pd==1)        &#123;            printf(&quot;%d&quot;,cs[tail]);            return 0;        &#125;    &#125;    printf(&quot;-1&quot;);    return 0;&#125;</code></pre><h2 id="洛谷-P1825-USACO11OPEN-玉米田迷宫Corn-Maze"><a href="#洛谷-P1825-USACO11OPEN-玉米田迷宫Corn-Maze" class="headerlink" title="洛谷 P1825 [USACO11OPEN]玉米田迷宫Corn Maze"></a>洛谷 P1825 [USACO11OPEN]玉米田迷宫Corn Maze</h2><p>在地图型bfs的基础上增加了传送门。</p><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P1825" title="https://www.luogu.org/problem/P1825">https://www.luogu.org/problem/P1825</a></p><p><img src="https://www.z4a.net/images/2019/08/14/bfs-5.1.jpg" alt="bfs-5.1.jpg"></p><p><img src="https://www.z4a.net/images/2019/08/14/bfs-5.2.jpg" alt="bfs-5.2.jpg"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>看题可知，传送门只会成对出现，并且与二十六个大写英文字母一一对应，不会出现一个字母对应两组传送门的情况。</p><p>并且，传送门可以来回传送，但是这里有一个小坑，就是当你到达传送门所在位置的时候，必须执行传送操作，而你再想传送回来，则需要在对面的传送门向外走出一格再走回来。</p><p>当时写这道题的时候在这个坑这里倒了快一个小时，分析数据和结果分析出来的。</p><p>然后代码写得比较乱，看bfs函数里面的标记已走过位置的时候可能无法理解…反正看懂了大概思路就行，这些小细节因人而异。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;int mapv[505][505]=&#123;0&#125;;char map[505][505];int trans[255][5]=&#123;0&#125;;struct que&#123;    int x;    int y;    int sec;&#125;que[500005];int pd=0;int m,n;int begi,begj;int head,tail;int xa[5]=&#123;-1,0,1,0&#125;;int ya[5]=&#123;0,-1,0,1&#125;;void bfs(int q)&#123;    for(int i=0;i&lt;=3;i++)    &#123;        if((que[q].x+xa[i])&gt;=0&amp;&amp;(que[q].x+xa[i])&lt;=n-1&amp;&amp;(que[q].y+ya[i])&gt;=0&amp;&amp;(que[q].y+ya[i])&lt;=m-1)        &#123;            if(map[que[q].x+xa[i]][que[q].y+ya[i]]==&#39;=&#39;)            &#123;                pd=1;                printf(&quot;%d\n&quot;,que[q].sec+1);                return;            &#125;            if(mapv[que[q].x+xa[i]][que[q].y+ya[i]]==0&amp;&amp;map[que[q].x+xa[i]][que[q].y+ya[i]]!=&#39;#&#39;)            &#123;                if(map[que[q].x+xa[i]][que[q].y+ya[i]]&gt;=&#39;A&#39;&amp;&amp;map[que[q].x+xa[i]][que[q].y+ya[i]]&lt;=&#39;Z&#39;)                &#123;                    tail++;                    if((que[q].x+xa[i]+1)*m+que[q].y+ya[i]==trans[map[que[q].x+xa[i]][que[q].y+ya[i]]][1])                    &#123;                        que[tail].x=trans[map[que[q].x+xa[i]][que[q].y+ya[i]]][2]/m-1;                        que[tail].y=trans[map[que[q].x+xa[i]][que[q].y+ya[i]]][2]%m;                        que[tail].sec=que[q].sec+1;                    &#125;                    else                    &#123;                        que[tail].x=trans[map[que[q].x+xa[i]][que[q].y+ya[i]]][1]/m-1;                        que[tail].y=trans[map[que[q].x+xa[i]][que[q].y+ya[i]]][1]%m;                        que[tail].sec=que[q].sec+1;                    &#125;                    que[tail].sec=que[q].sec+1;                &#125;                else                &#123;                    tail++;                    que[tail].x=que[q].x+xa[i];                    que[tail].y=que[q].y+ya[i];                    que[tail].sec=que[q].sec+1;                    mapv[que[q].x+xa[i]][que[q].y+ya[i]]=1;                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=0;i&lt;=n-1;i++)    &#123;        scanf(&quot;%s&quot;,map[i]);    &#125;    for(int i=0;i&lt;=n-1;i++)    &#123;        for(int j=0;j&lt;=m-1;j++)        &#123;            if(map[i][j]==&#39;@&#39;)            &#123;                begi=i;                begj=j;            &#125;            if(map[i][j]&gt;=&#39;A&#39;&amp;&amp;map[i][j]&lt;=&#39;Z&#39;)            &#123;                if(trans[map[i][j]][1]==0)                &#123;                    trans[map[i][j]][1]=(i+1)*m+j;                &#125;                else                &#123;                    trans[map[i][j]][2]=(i+1)*m+j;                &#125;            &#125;        &#125;    &#125;    head=1,tail=1;    que[1].x=begi;    que[1].y=begj;    que[1].sec=0;    mapv[begi][begj]=1;    while(head&lt;=tail)    &#123;        bfs(head);        head++;        if(pd==1)        &#123;            break;        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="洛谷-P1126-机器人搬重物"><a href="#洛谷-P1126-机器人搬重物" class="headerlink" title="洛谷 P1126 机器人搬重物"></a>洛谷 P1126 机器人搬重物</h2><p>这个题目的设置，包括每一步可走的点，以及这些点所能遇到的情况都非常复杂，当时打了一遍出来a了一半的点，改了一次又a了一半的一半，最后才改对。</p><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P1126" title="https://www.luogu.org/problem/P1126">https://www.luogu.org/problem/P1126</a></p><p><img src="https://www.z4a.net/images/2019/08/14/bfs-6.1.jpg" alt="bfs-6.1.jpg"></p><p><img src="https://www.z4a.net/images/2019/08/14/bfs-6.2.jpg" alt="bfs-6.2.jpg"></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>首先，题目中提及机器人的形状是直径1.6m的球，然后机器人在格点上行走。而在地图上给出的黑色位置，实际上会占据四个格点。这就需要我们在录入地图的时候做出一些巧妙的变化。</p><p>此处搬一下题解里雒仁韬大佬所画的图（我不认识这位大佬，如果大佬觉得搬图侵权啥的我可以删掉）</p><p><img src="https://www.z4a.net/images/2019/08/14/bfs-6.3.JPG.png" alt="bfs-6.3.JPG.png"></p><p>其次，机器人可以朝面前方向行走一格两格或者三格，但是这都是在前方没有不能行走的格点的情况下，如果行走三格，就要看看前方两格三格的地方有没有障碍物。</p><p>另外，贮藏室，也就是整张地图的外围一圈是有墙体的，这点在上面那位大佬的图中也有体现。</p><p>最后，普通bfs对于每个格子打上标记，而我写这道题是对每个格子的每个方向都打上标记。我写的代码有四百行，因为其中包含着很多的判断分支，肯定是可以简化的，也会有简单一些的办法，或者说查看一下大佬们的解法都可以。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;int mak[55][55][5]=&#123;0&#125;; int head,tail;int a,b,c,d;int jud=0;int n,m;struct que&#123;    int x;    int y;    int sec;    int fx;      //方向：0 上 1 右 2 下 3 左&#125;que[50005];void bfs(int ceng)&#123;    for(int i=1;i&lt;=5;i++)  //4:向右 5:向左     &#123;        switch(i)        &#123;            case 1:                &#123;                    switch(que[ceng].fx)                    &#123;                        case 0:                            &#123;                                if(que[ceng].x-1&gt;=1)                                &#123;                                    if(mak[que[ceng].x-1][que[ceng].y][que[ceng].fx]==0)                                    &#123;                                        tail++;                                        que[tail].x=que[ceng].x-1;                                        que[tail].y=que[ceng].y;                                        que[tail].sec=que[ceng].sec+1;                                        que[tail].fx=que[ceng].fx;                                        if(que[tail].x==c&amp;&amp;que[tail].y==d)                                        &#123;                                            jud=1;                                            printf(&quot;%d\n&quot;,que[tail].sec);                                        &#125;                                        mak[que[tail].x][que[tail].y][que[tail].fx]=2;                                    &#125;                                &#125;                             &#125;                        break;                        case 1:                            &#123;                                if(que[ceng].y+1&lt;=m+1)                                &#123;                                    if(mak[que[ceng].x][que[ceng].y+1][que[ceng].fx]==0)                                    &#123;                                        tail++;                                        que[tail].x=que[ceng].x;                                        que[tail].y=que[ceng].y+1;                                        que[tail].sec=que[ceng].sec+1;                                        que[tail].fx=que[ceng].fx;                                        if(que[tail].x==c&amp;&amp;que[tail].y==d)                                        &#123;                                            jud=1;                                            printf(&quot;%d\n&quot;,que[tail].sec);                                        &#125;                                        mak[que[tail].x][que[tail].y][que[tail].fx]=2;                                    &#125;                                &#125;                            &#125;                        break;                        case 2:                            &#123;                                if(que[ceng].x+1&lt;=n+1)                                &#123;                                    if(mak[que[ceng].x+1][que[ceng].y][que[ceng].fx]==0)                                    &#123;                                        tail++;                                        que[tail].x=que[ceng].x+1;                                        que[tail].y=que[ceng].y;                                        que[tail].sec=que[ceng].sec+1;                                        que[tail].fx=que[ceng].fx;                                        if(que[tail].x==c&amp;&amp;que[tail].y==d)                                        &#123;                                            jud=1;                                            printf(&quot;%d\n&quot;,que[tail].sec);                                        &#125;                                        mak[que[tail].x][que[tail].y][que[tail].fx]=2;                                    &#125;                                &#125;                            &#125;                        break;                        case 3:                            &#123;                                if(que[ceng].y-1&gt;=1)                                &#123;                                    if(mak[que[ceng].x][que[ceng].y-1][que[ceng].fx]==0)                                    &#123;                                        tail++;                                        que[tail].x=que[ceng].x;                                        que[tail].y=que[ceng].y-1;                                        que[tail].sec=que[ceng].sec+1;                                        que[tail].fx=que[ceng].fx;                                        if(que[tail].x==c&amp;&amp;que[tail].y==d)                                        &#123;                                            jud=1;                                            printf(&quot;%d\n&quot;,que[tail].sec);                                        &#125;                                        mak[que[tail].x][que[tail].y][que[tail].fx]=2;                                    &#125;                                &#125;                            &#125;                        break;                    &#125;                &#125;            break;            case 2:                &#123;                    switch(que[ceng].fx)                    &#123;                        case 0:                            &#123;                                if(que[ceng].x-2&gt;=1)                                &#123;                                    if(mak[que[ceng].x-2][que[ceng].y][que[ceng].fx]==0&amp;&amp;mak[que[ceng].x-1][que[ceng].y][que[ceng].fx]!=1)                                    &#123;                                        tail++;                                        que[tail].x=que[ceng].x-2;                                        que[tail].y=que[ceng].y;                                        que[tail].sec=que[ceng].sec+1;                                        que[tail].fx=que[ceng].fx;                                        if(que[tail].x==c&amp;&amp;que[tail].y==d)                                        &#123;                                            jud=1;                                            printf(&quot;%d\n&quot;,que[tail].sec);                                        &#125;                                        mak[que[tail].x][que[tail].y][que[tail].fx]=2;                                    &#125;                                &#125;                             &#125;                        break;                        case 1:                            &#123;                                if(que[ceng].y+2&lt;=m+1)                                &#123;                                    if(mak[que[ceng].x][que[ceng].y+2][que[ceng].fx]==0&amp;&amp;mak[que[ceng].x][que[ceng].y+1][que[ceng].fx]!=1)                                    &#123;                                        tail++;                                        que[tail].x=que[ceng].x;                                        que[tail].y=que[ceng].y+2;                                        que[tail].sec=que[ceng].sec+1;                                        que[tail].fx=que[ceng].fx;                                        if(que[tail].x==c&amp;&amp;que[tail].y==d)                                        &#123;                                            jud=1;                                            printf(&quot;%d\n&quot;,que[tail].sec);                                        &#125;                                        mak[que[tail].x][que[tail].y][que[tail].fx]=2;                                    &#125;                                &#125;                            &#125;                        break;                        case 2:                            &#123;                                if(que[ceng].x+2&lt;=n+1)                                &#123;                                    if(mak[que[ceng].x+2][que[ceng].y][que[ceng].fx]==0&amp;&amp;mak[que[ceng].x+1][que[ceng].y][que[ceng].fx]!=1)                                    &#123;                                        tail++;                                        que[tail].x=que[ceng].x+2;                                        que[tail].y=que[ceng].y;                                        que[tail].sec=que[ceng].sec+1;                                        que[tail].fx=que[ceng].fx;                                        if(que[tail].x==c&amp;&amp;que[tail].y==d)                                        &#123;                                            jud=1;                                            printf(&quot;%d\n&quot;,que[tail].sec);                                        &#125;                                        mak[que[tail].x][que[tail].y][que[tail].fx]=2;                                    &#125;                                &#125;                            &#125;                        break;                        case 3:                            &#123;                                if(que[ceng].y-2&gt;=1)                                &#123;                                    if(mak[que[ceng].x][que[ceng].y-2][que[ceng].fx]==0&amp;&amp;mak[que[ceng].x][que[ceng].y-1][que[ceng].fx]!=1)                                    &#123;                                        tail++;                                        que[tail].x=que[ceng].x;                                        que[tail].y=que[ceng].y-2;                                        que[tail].sec=que[ceng].sec+1;                                        que[tail].fx=que[ceng].fx;                                        if(que[tail].x==c&amp;&amp;que[tail].y==d)                                        &#123;                                            jud=1;                                            printf(&quot;%d\n&quot;,que[tail].sec);                                        &#125;                                        mak[que[tail].x][que[tail].y][que[tail].fx]=2;                                    &#125;                                &#125;                            &#125;                        break;                    &#125;                &#125;            break;            case 3:                &#123;                    switch(que[ceng].fx)                    &#123;                        case 0:                            &#123;                                if(que[ceng].x-3&gt;=1)                                &#123;                                    if(mak[que[ceng].x-3][que[ceng].y][que[ceng].fx]==0&amp;&amp;mak[que[ceng].x-2][que[ceng].y][que[ceng].fx]!=1&amp;&amp;mak[que[ceng].x-1][que[ceng].y][que[ceng].fx]!=1)                                    &#123;                                        tail++;                                        que[tail].x=que[ceng].x-3;                                        que[tail].y=que[ceng].y;                                        que[tail].sec=que[ceng].sec+1;                                        que[tail].fx=que[ceng].fx;                                        if(que[tail].x==c&amp;&amp;que[tail].y==d)                                        &#123;                                            jud=1;                                            printf(&quot;%d\n&quot;,que[tail].sec);                                        &#125;                                        mak[que[tail].x][que[tail].y][que[tail].fx]=2;                                    &#125;                                                                    &#125;                             &#125;                        break;                        case 1:                            &#123;                                if(que[ceng].y+3&lt;=m+1)                                &#123;                                    if(mak[que[ceng].x][que[ceng].y+3][que[ceng].fx]==0&amp;&amp;mak[que[ceng].x][que[ceng].y+2][que[ceng].fx]!=1&amp;&amp;mak[que[ceng].x][que[ceng].y+1][que[ceng].fx]!=1)                                    &#123;                                        tail++;                                        que[tail].x=que[ceng].x;                                        que[tail].y=que[ceng].y+3;                                        que[tail].sec=que[ceng].sec+1;                                        que[tail].fx=que[ceng].fx;                                        if(que[tail].x==c&amp;&amp;que[tail].y==d)                                        &#123;                                            jud=1;                                            printf(&quot;%d\n&quot;,que[tail].sec);                                        &#125;                                        mak[que[tail].x][que[tail].y][que[tail].fx]=2;                                    &#125;                                &#125;                            &#125;                        break;                        case 2:                            &#123;                                if(que[ceng].x+3&lt;=n+1)                                &#123;                                    if(mak[que[ceng].x+3][que[ceng].y][que[ceng].fx]==0&amp;&amp;mak[que[ceng].x+2][que[ceng].y][que[ceng].fx]!=1&amp;&amp;mak[que[ceng].x+1][que[ceng].y][que[ceng].fx]!=1)                                    &#123;                                        tail++;                                        que[tail].x=que[ceng].x+3;                                        que[tail].y=que[ceng].y;                                        que[tail].sec=que[ceng].sec+1;                                        que[tail].fx=que[ceng].fx;                                        if(que[tail].x==c&amp;&amp;que[tail].y==d)                                        &#123;                                            jud=1;                                            printf(&quot;%d\n&quot;,que[tail].sec);                                        &#125;                                        mak[que[tail].x][que[tail].y][que[tail].fx]=2;                                    &#125;                                &#125;                            &#125;                        break;                        case 3:                            &#123;                                if(que[ceng].y-3&gt;=1)                                &#123;                                    if(mak[que[ceng].x][que[ceng].y-3][que[ceng].fx]==0&amp;&amp;mak[que[ceng].x][que[ceng].y-2][que[ceng].fx]!=1&amp;&amp;mak[que[ceng].x][que[ceng].y-1][que[ceng].fx]!=1)                                    &#123;                                        tail++;                                        que[tail].x=que[ceng].x;                                        que[tail].y=que[ceng].y-3;                                        que[tail].sec=que[ceng].sec+1;                                        que[tail].fx=que[ceng].fx;                                        if(que[tail].x==c&amp;&amp;que[tail].y==d)                                        &#123;                                            jud=1;                                            printf(&quot;%d\n&quot;,que[tail].sec);                                        &#125;                                        mak[que[tail].x][que[tail].y][que[tail].fx]=2;                                    &#125;                                &#125;                            &#125;                        break;                    &#125;                &#125;            break;            case 4:                &#123;                    if(mak[que[ceng].x][que[ceng].y][(que[ceng].fx+1)%4]==0)                    &#123;                        tail++;                        que[tail].x=que[ceng].x;                        que[tail].y=que[ceng].y;                        que[tail].sec=que[ceng].sec+1;                        que[tail].fx=que[ceng].fx+1;                        que[tail].fx%=4;                        mak[que[tail].x][que[tail].y][que[tail].fx]=2;                    &#125;                &#125;            break;            case 5:                &#123;                    if(mak[que[ceng].x][que[ceng].y][(que[ceng].fx+3)%4]==0)                    &#123;                        tail++;                        que[tail].x=que[ceng].x;                        que[tail].y=que[ceng].y;                        que[tail].sec=que[ceng].sec+1;                        que[tail].fx=que[ceng].fx+3;                        que[tail].fx%=4;                        mak[que[tail].x][que[tail].y][que[tail].fx]=2;                    &#125;                &#125;            break;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    int k;    char e;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=m;j++)        &#123;            scanf(&quot;%d&quot;,&amp;k);            if(k==1)            &#123;                for(int q=0;q&lt;=3;q++)                &#123;                    mak[i][j][q]=1;                    mak[i][j+1][q]=1;                    mak[i+1][j][q]=1;                    mak[i+1][j+1][q]=1;                &#125;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=n+1;i++)    &#123;        for(int q=0;q&lt;=3;q++)        &#123;            mak[i][1][q]=1;            mak[i][m+1][q]=1;        &#125;    &#125;    for(int j=1;j&lt;=m+1;j++)    &#123;        for(int q=0;q&lt;=3;q++)        &#123;            mak[1][j][q]=1;            mak[n+1][j][q]=1;        &#125;    &#125;    scanf(&quot;%d%d%d%d %c&quot;,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e);    head=1;    tail=1;    a+=1;    b+=1;    c+=1;    d+=1;    if(a==c&amp;&amp;b==d)    &#123;        printf(&quot;0&quot;);        return 0;    &#125;    que[head].x=a;    que[head].y=b;    que[head].sec=0;    switch(e)    &#123;        case &#39;N&#39;:que[head].fx=0;        break;        case &#39;E&#39;:que[head].fx=1;        break;        case &#39;S&#39;:que[head].fx=2;        break;        case &#39;W&#39;:que[head].fx=3;        break;    &#125;    mak[a][b][que[head].fx]=1;    while(head&lt;=tail)    &#123;        bfs(head);        head++;        if(jud==1)//下一步已经试探出终点         &#123;            break;        &#125;    &#125;    if(jud==0)    &#123;        printf(&quot;-1&quot;);    &#125;    return 0;&#125;</code></pre><h2 id="洛谷-P1902-刺杀大使"><a href="#洛谷-P1902-刺杀大使" class="headerlink" title="洛谷 P1902 刺杀大使"></a>洛谷 P1902 刺杀大使</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P1902" title="https://www.luogu.org/problem/P1902">https://www.luogu.org/problem/P1902</a></p><p><img src="https://www.z4a.net/images/2019/08/22/bfs-6.4.jpg" alt="bfs-6.4.jpg"></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>二分答案+bfs能否到达</p><p>未完待续……</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;#define MAX 10005int v[1005][1005]=&#123;0&#125;;struct que&#123;    int x1;    int y1;&#125;que[1000005];int xa[5]=&#123;0,-1,0,1&#125;;int ya[5]=&#123;-1,0,1,0&#125;;int a[1005][1005];int head,tail;int r,l;int pd;int m,n;int mid;void bfs(int x,int y)&#123;    for(int i=0;i&lt;=3;i++)    &#123;        if(x+xa[i]&lt;=n&amp;&amp;x+xa[i]&gt;=1&amp;&amp;y+ya[i]&lt;=m&amp;&amp;y+ya[i]&gt;=1)        &#123;            if(v[x+xa[i]][y+ya[i]]==0)            &#123;                if(x+xa[i]==n)                &#123;                    pd=1;                &#125;                v[x+xa[i]][y+ya[i]]=1;                tail++;                que[tail].x1=x+xa[i];                que[tail].y1=y+ya[i];            &#125;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=m;j++)        &#123;            scanf(&quot;%d&quot;,&amp;a[i][j]);        &#125;    &#125;    r=1000;    l=0;    while(r&gt;=l)    &#123;        head=1,tail=1;        pd=0;        mid=(r+l)/2;        for(int i=1;i&lt;=n;i++)        &#123;            for(int j=1;j&lt;=m;j++)            &#123;                if(a[i][j]&gt;mid)                &#123;                    v[i][j]=1;                &#125;                else                &#123;                    v[i][j]=0;                &#125;            &#125;        &#125;        que[1].x1=1;        que[1].y1=1;        while(head&lt;=tail)        &#123;            bfs(que[head].x1,que[head].y1);            head++;            if(pd==1)            &#123;                break;            &#125;        &#125;        if(pd==1)        &#123;            r=mid-1;        &#125;        else        &#123;            l=mid+1;        &#125;    &#125;    printf(&quot;%d&quot;,r+1);    return 0;&#125;</code></pre><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在我看来，每种算法都由两个部分组成，一部分是思想，另外一部分就是实现能力，二者缺一不可。缺少思想，算法就无法站住，或者可以说固定的模板无法和灵活的题目相联系。缺少实现能力，算法就成了空中楼阁，你想到的思路再清晰再高明，打不出来终究是心有余力不足。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://www.unknown9t.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索算法" scheme="http://www.unknown9t.com/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
    <category term="bfs" scheme="http://www.unknown9t.com/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>Floyd（弗洛伊德）</title>
    <link href="http://www.unknown9t.com/2022/04/29/Floyd/"/>
    <id>http://www.unknown9t.com/2022/04/29/Floyd/</id>
    <published>2022-04-29T13:49:08.120Z</published>
    <updated>2019-08-21T15:31:16.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>到了如今，最短路问题已经得到了很多种解法。这些解法有相同的地方，也有不同的地方，性能也有所差异。但是，如果一种问题得出的某种解法优于其他解法太多，其他这些解法就应该随时间流逝而被逐渐淘汰。最短路问题的这些解法如今仍屹立不倒，足可说明它们各有偏重的方向。</p><span id="more"></span><p>floyd，（又称Floyd-Warshall）即弗洛伊德算法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法。简单来说，是一种能够解决多源最短路的算法。但是，floyd无法处理具有负权环的图。这里提一句，floyd同样可以解决图的连通性问题。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>同大多数动态规划算法一样，floyd的核心代码只有短短几行。</p><pre><code>for(int k=1;k&lt;=n;k++)&#123;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            if(h[i][k]+h[k][j]&lt;h[i][j])            &#123;                h[i][j]=h[i][k]+h[k][j];                h[j][i]=h[i][k]+h[k][j];            &#125;        &#125;    &#125;&#125;</code></pre><p>在这几行中，却是三重循环嵌套，这导致floyd的时间复杂度达到了O(n^3)。但是，与其相对应的是floyd对于稠密图处理的简单与高效。另外，floyd对于每对起点终点枚举的查询方式，造成了它能够解决多源最短路的特性。</p><h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><p>我们开始进行floyd整个过程的讲解。</p><p>首先，我们定义一个二维数组记录每两个点之间的距离，二维数组的大小取决于图中点的个数。这一步来构建邻接矩阵建立我们的图。我们暂定这个数组名为h。</p><p>对于这个邻接矩阵（也就是该二维数组），我们对其每一个位置进行初始化，将其初始化为一个极大值，代表两点之间无法连通。随后将题目中所给边连接，即将h数组中两点对应的位置设置成题目中所给值。如此，图中直接连通的两点所对应的位置已经不是某无穷大的值了。</p><p>需要提前处理的点都处理好了，接下来就是循环嵌套的过程。</p><p>在这个循环嵌套的过程中，我们完成三重循环，分别是枚举终点起点以及枚举它们之间的中转点（例如1-3连通而1-2以及2-3分别连通，那么2可以叫做1与3的中转点）。我们需要判断起点到终点的距离是否比通过中转点的距离更远，或者说起点到终点所需要花费的值是否大于通过中转点所花费的值。落实到公式上就是这样：</p><pre><code>if(h[i][k]+h[k][j]&lt;h[i][j])&#123;    h[i][j]=h[i][k]+h[k][j];//i代表起点，j代表终点，k代表中转点。&#125;</code></pre><p>我们可以看出来，h数组记录的始终是当前情况下i到j的最短距离。</p><p>那么，我们的三重循环貌似应该是这样的：</p><pre><code>for(int i=1;i&lt;=n;i++)&#123;    for(int j=1;j&lt;=n;j++)    &#123;        for(int k=1;k&lt;=n;k++)        &#123;            if(h[i][k]+h[k][j]&lt;h[i][j])            &#123;                h[i][j]=h[i][k]+h[k][j];            &#125;            &#125;    &#125;&#125;</code></pre><p>你可能看到我说的“貌似”二字，或者看出来了这个三重循环和我一开始写的核心代码之间的不同点。没错，这样的三重循环是不对的，而这个循环嵌套仅仅是把中转点的循环放到了内层。</p><p>这样为什么就会出错呢？我们来看看这个问题。</p><p>原核心代码是把中转点的枚举放在了最外层，我们可以分析得出来，核心代码的意愿是对于每一个中转点，分析每一对起点终点是否可以通过该中转点松弛（当然你也可以叫它优化）。这样对于每一次枚举到的中转点，每对起点终点都会被遍历一次，在最后一个中转点时，仍然还可以修改每对起点终点的最小值。</p><p>而将中转点的枚举放在最内层，我们分析得来，实现过程是对每一对起点终点枚举所有点来当作中转点。这样的话对于这对起点终点来说，属于它们的最外层循环走完之后，它们的最短距离就相对固定了，在之后的循环中再没有对它们的操作了，这会导致错误。</p><p>我们也可以这么理解：我们对于每一个新增的节点k，来判断这个k是否对于已经确定的最短路有什么影响。而随着k的增加，最终达到整张原图的大小，此时k对每条最短路的影响都已经判断完毕了，故此时得到的每两个点之间的最短路就是整张图背景下两个点之间的最短路。</p><p>我们来举几个例子帮助大家理解。（例子取自大佬博客，地址下面放出）</p><p><a href="https://blog.csdn.net/qq_27765961/article/details/51915384" title="https://blog.csdn.net/qq_27765961/article/details/51915384">https://blog.csdn.net/qq_27765961&#x2F;article&#x2F;details&#x2F;51915384</a></p><p>例子是取自这篇博客，但是我还是重新画一下图片吧。</p><p>第一个例子是这个样子的</p><p><img src="https://www.z4a.net/images/2019/08/19/floyd-1.4.jpg" alt="floyd-1.1.jpg"></p><p>若把中转点循环放在内层，过程如下：</p><p>未循环时是这样的邻接矩阵。</p><p><img src="https://www.z4a.net/images/2019/08/19/floyd-1.5.jpg" alt="floyd-1.2.jpg"></p><p>i&#x3D;1结束之后变成了这样。</p><p><img src="https://www.z4a.net/images/2019/08/19/floyd-1.6.jpg" alt="floyd-1.3.jpg"></p><p>i&#x3D;2结束之后还是上图那样。</p><p>这样我们就看出来了，1与2之间的距离之后的过程中就不会再更改了，而很明显我们可以从图中看出来最短距离是3。</p><p>为了保险起见，我们把中转点循环在最外层的过程也捋一遍。</p><p>仍然是这俩图。</p><p><img src="https://www.z4a.net/images/2019/08/19/floyd-1.4.jpg" alt="floyd-1.1.jpg"></p><p><img src="https://www.z4a.net/images/2019/08/19/floyd-1.5.jpg" alt="floyd-1.2.jpg"></p><p>k&#x3D;1结束之后，邻接矩阵没有发生变化。</p><p>k&#x3D;2的时候也是一样的。（规律好像与行列有关）</p><p>k&#x3D;3即3作为中转点的时候发生了变化。</p><p><img src="https://www.z4a.net/images/2019/08/19/floyd-1.7.jpg" alt="floyd-1.7.jpg"></p><p>k&#x3D;4之后最终的邻接矩阵变成了这样。</p><p><img src="https://www.z4a.net/images/2019/08/19/floyd-1.8.jpg" alt="floyd-1.8.jpg"></p><p>很明显得到了1与2之间的最短距离为3。</p><p>大家可能发现了，上面这个例子是一个有向图的例子，边只能单向通过，所以我在图中只是画了箭头，而没有画直线。那么，会不会k在内层只是在有向图中错误呢？我们用第二个例子验证一下。</p><p>我在第二个例子中只判断图的连通性，实际上简化了过程，连通则在邻接矩阵中置1，非连通则置0。</p><p><img src="https://www.z4a.net/images/2019/08/19/floyd-3.3.jpg" alt="floyd-3.3.jpg"></p><p><img src="https://www.z4a.net/images/2019/08/19/floyd-3.4.jpg" alt="floyd-3.4.jpg"></p><p>i&#x3D;1时只是与4连通，而i&#x3D;2的时候也只是2与4连通。你可能会说，1和2都与4连通那它们不就连通了，但是程序不知道这点，程序只知道i过了2之后，1和2的连通状态不会再改变了，并且在最后，1和2也是未连通的状态。</p><p>另外，还有几个问题。</p><p>一个是，k在最外层的话，先经历哪一个点为中转点对这个过程有影响吗？换句话说就是顺序是否对floyd产生影响。</p><p>还有一个是关于为何floyd被定义为是动态规划算法。</p><p>这两个问题在下面这篇大佬的博客中有所解释，我就不搬运了，网址放出来。</p><p><a href="https://www.cnblogs.com/LiHior/p/7701296.html" title="https://www.cnblogs.com/LiHior/p/7701296.html">https://www.cnblogs.com/LiHior/p/7701296.html</a></p><h2 id="标准代码"><a href="#标准代码" class="headerlink" title="标准代码"></a>标准代码</h2><p>我假设一共n个点m条边的无向图做了一个标准代码，仅供参考。</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define MAX 99999999int h[105][105];int main()&#123;    int n,m;//n个点,m条边    int a,b,v;     scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            h[i][j]=MAX;        &#125;    &#125;    for(int i=1;i&lt;=m;i++)    &#123;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;v);        h[a][b]=v;        h[b][a]=v;    &#125;     for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            printf(&quot;%d &quot;,h[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    for(int k=1;k&lt;=n;k++)    &#123;        for(int i=1;i&lt;=n;i++)        &#123;            for(int j=1;j&lt;=n;j++)            &#123;                if(h[i][k]+h[k][j]&lt;h[i][j])                &#123;                    h[i][j]=h[i][k]+h[k][j];                    h[j][i]=h[i][k]+h[k][j];                &#125;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            printf(&quot;%d &quot;,h[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125;</code></pre><p>floyd的逻辑很清晰，相信大家自己也可以一步一步走出每一步的作用。另外在上面已经尝试着分析过一段核心代码了，在这里我就不对标准代码做讲解了。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="HDU-2544-最短路"><a href="#HDU-2544-最短路" class="headerlink" title="HDU 2544 最短路"></a>HDU 2544 最短路</h3><p>就是一个模板的单源最短路。</p><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="acm.hdu.edu.cn/showproblem.php?pid=2544" title="acm.hdu.edu.cn/showproblem.php?pid=2544">acm.hdu.edu.cn&#x2F;showproblem.php?pid&#x3D;2544</a></p><p><img src="https://www.z4a.net/images/2019/08/19/floyd-4.1.jpg" alt="floyd-4.1.jpg"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>就是个很普通的单源最短路，按照正常的流程，初始化，核心就可以解决。需要注意的点有一个，就是题目中说C&lt;&#x3D;1000，是不准确的，需要把最大值调整到200000。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>#include&lt;stdio.h&gt;#define MAX 200005int main()&#123;    int n,m;    int a,b,c;    int h[105][105];    while(1)    &#123;        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        if(n==0&amp;&amp;m==0)        &#123;            break;        &#125;        for(int i=1;i&lt;=n;i++)        &#123;            for(int j=1;j&lt;=n;j++)            &#123;                h[i][j]=MAX;            &#125;        &#125;        for(int i=1;i&lt;=m;i++)        &#123;            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);            h[a][b]=c;            h[b][a]=c;        &#125;        for(int k=1;k&lt;=n;k++)        &#123;            for(int i=1;i&lt;=n;i++)            &#123;                for(int j=1;j&lt;=n;j++)                &#123;                    if(h[i][j]&gt;h[i][k]+h[k][j])                    &#123;                        h[i][j]=h[i][k]+h[k][j];                        h[j][i]=h[i][j];                    &#125;                &#125;            &#125;        &#125;        printf(&quot;%d\n&quot;,h[1][n]);    &#125;    return 0;&#125;</code></pre><h3 id="洛谷-P2910-USACO08OPEN-寻宝之路Clear-And-Present-Danger"><a href="#洛谷-P2910-USACO08OPEN-寻宝之路Clear-And-Present-Danger" class="headerlink" title="洛谷 P2910 [USACO08OPEN]寻宝之路Clear And Present Danger"></a>洛谷 P2910 [USACO08OPEN]寻宝之路Clear And Present Danger</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.luogu.org/problem/P2910" title="https://www.luogu.org/problem/P2910">https://www.luogu.org/problem/P2910</a></p><p><img src="https://www.z4a.net/images/2019/08/21/floyd-5.1.jpg" alt="floyd-5.1.jpg"></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>首先题目中提及，a到b的危险指数不一定等于b到a的危险指数，可知是有向图。</p><p>另外，本题的输入给出了整个邻接矩阵，并且特别指出了每个岛到自己本身的危险程度为0。我们不需要对邻接矩阵赋极大的初值了。</p><p>最后，我们要在一开始记录下路线，并且在floyd核心运行完毕之后，对每一对相邻的点的危险程度进行求和。所得到的值就是最后的危险指数。</p><p>别的就没啥好说的了，就是一个很普通很裸的floyd，多源最短路嘛。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code>#include&lt;stdio.h&gt;int main()&#123;    int n,m,v;    int sum=0;    int a[10005];    int h[105][105];    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=m;i++)    &#123;        scanf(&quot;%d&quot;,&amp;a[i]);    &#125;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            scanf(&quot;%d&quot;,&amp;v);            h[i][j]=v;        &#125;    &#125;    for(int k=1;k&lt;=n;k++)    &#123;        for(int i=1;i&lt;=n;i++)        &#123;            for(int j=1;j&lt;=n;j++)            &#123;                if(h[i][k]+h[k][j]&lt;h[i][j])                &#123;                    h[i][j]=h[i][k]+h[k][j];                &#125;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=m-1;i++)    &#123;        sum+=h[a[i]][a[i+1]];        &#125;    printf(&quot;%d&quot;,sum);    return 0;&#125;</code></pre><h3 id="洛谷-P2935-USACO09JAN-最好的地方Best-Spot"><a href="#洛谷-P2935-USACO09JAN-最好的地方Best-Spot" class="headerlink" title="洛谷 P2935 [USACO09JAN]最好的地方Best Spot"></a>洛谷 P2935 [USACO09JAN]最好的地方Best Spot</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.luogu.org/problem/P2935" title="https://www.luogu.org/problem/P2935">https://www.luogu.org/problem/P2935</a></p><p><img src="https://www.z4a.net/images/2019/08/21/floyd-6.1.jpg" alt="floyd-6.1.jpg"></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>题目一开始也是提及，连通的路都是双向边，所以是一个无向图。</p><p>据题意所说，我们需要得到每一个牧场到其他牧场的最短路，然后再求出每一个牧场到某些特定牧场最短距离的平均值最后选一个平均值最小的。也是一个典型的多源最短路，最短路的过程也不再说了。</p><p>题目中说最多500个点，却只有最多8000条边，我们把整个邻接矩阵初始化，随后记录特定的牧场都有哪些。</p><p>而在最后加和求平均值的过程中要注意，若由某牧场到某牧场本身，则跳过加和，因为距离应该为0，但实际上在一开始我们给邻接矩阵赋上了初值，无论最后有没有得到松弛，都会影响最终结果。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre><code>#include&lt;stdio.h&gt;#define MAX 100005int main()&#123;    int p,f,c;    int a,b,v;    int aver;    int ans;    int min=1000005;    int want[505];    int h[505][505];    scanf(&quot;%d%d%d&quot;,&amp;p,&amp;f,&amp;c);    for(int i=1;i&lt;=f;i++)    &#123;        scanf(&quot;%d&quot;,&amp;want[i]);    &#125;    for(int i=1;i&lt;=p;i++)    &#123;        for(int j=1;j&lt;=p;j++)        &#123;            h[i][j]=MAX;        &#125;    &#125;    for(int i=1;i&lt;=c;i++)    &#123;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;v);        h[a][b]=v;        h[b][a]=v;    &#125;    for(int k=1;k&lt;=p;k++)    &#123;        for(int i=1;i&lt;=p;i++)        &#123;            for(int j=1;j&lt;=p;j++)            &#123;                if(h[i][k]+h[k][j]&lt;h[i][j])                &#123;                    h[i][j]=h[i][k]+h[k][j];                    h[j][i]=h[i][j];                &#125;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=p;i++)    &#123;        aver=0;        for(int j=1;j&lt;=f;j++)        &#123;            if(i!=want[j])            &#123;                    aver+=h[i][want[j]];            &#125;        &#125;        if(aver&lt;min)        &#123;            min=aver;            ans=i;        &#125;    &#125;    printf(&quot;%d&quot;,ans);    return 0;&#125;</code></pre><h3 id="洛谷-P2888-USACO07NOV-牛栏Cow-Hurdles"><a href="#洛谷-P2888-USACO07NOV-牛栏Cow-Hurdles" class="headerlink" title="洛谷 P2888 [USACO07NOV]牛栏Cow Hurdles"></a>洛谷 P2888 [USACO07NOV]牛栏Cow Hurdles</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.luogu.org/problem/P2888" title="https://www.luogu.org/problem/P2888">https://www.luogu.org/problem/P2888</a></p><p><img src="https://www.z4a.net/images/2019/08/21/floyd-7.1.jpg" alt="floyd-7.1.jpg"></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>这道题的floyd稍微有一点隐晦，没有直接指出最短路，而是一条路上最大的花费等于这条路的花费，不断松弛找到每两个点之间最高的栏（最大的花费）的最小值（最大花费最小的那条路）。</p><p>做这道题我们只需要把floyd的核心代码中的判断稍微修改一下。</p><p>题目中提及单向路径，故是一个有向图。</p><p>题目中给出了多个任务，故也可以看出是一个多源问题。</p><p>最后，有可能无法到达，也就是无法满足任务，输出-1，我把这里定成了栏的高度大于某个值就不满足，因为我在初始化时，用了一个极大值来记录无法通过的路径。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre><code>#include&lt;stdio.h&gt;#define MAX 1000010int max(int a1,int b1)&#123;    if(a1&gt;b1)    &#123;        return a1;    &#125;    else    &#123;        return b1;    &#125;&#125;int main()&#123;    int n,m,t;    int a,b,c;    int h[305][305];    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t);    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            h[i][j]=MAX;        &#125;    &#125;    for(int i=1;i&lt;=m;i++)    &#123;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        h[a][b]=c;    &#125;    for(int k=1;k&lt;=n;k++)    &#123;        for(int i=1;i&lt;=n;i++)        &#123;            for(int j=1;j&lt;=n;j++)            &#123;                if(max(h[i][k],h[k][j])&lt;=h[i][j])                &#123;                    h[i][j]=max(h[i][k],h[k][j]);                &#125;            &#125;        &#125;    &#125;    for(int i=1;i&lt;=t;i++)    &#123;        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        if(h[a][b]&lt;=1000000)        &#123;            printf(&quot;%d\n&quot;,h[a][b]);        &#125;        else        &#123;            printf(&quot;-1\n&quot;);        &#125;    &#125;    return 0;&#125;</code></pre><h1 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;到了如今，最短路问题已经得到了很多种解法。这些解法有相同的地方，也有不同的地方，性能也有所差异。但是，如果一种问题得出的某种解法优于其他解法太多，其他这些解法就应该随时间流逝而被逐渐淘汰。最短路问题的这些解法如今仍屹立不倒，足可说明它们各有偏重的方向。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://www.unknown9t.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图论" scheme="http://www.unknown9t.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="http://www.unknown9t.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>dfs习题讲解</title>
    <link href="http://www.unknown9t.com/2022/04/29/dfs%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3/"/>
    <id>http://www.unknown9t.com/2022/04/29/dfs%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3/</id>
    <published>2022-04-29T13:45:06.810Z</published>
    <updated>2019-08-13T16:17:25.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在我看来，每种算法都由两个部分组成，一部分是思想，另外一部分就是实现能力，二者缺一不可。缺少思想，算法就无法站住，或者可以说固定的模板无法和灵活的题目相联系。缺少实现能力，算法就成了空中楼阁，你想到的思路再清晰再高明，打不出来终究是心有余力不足。</p><span id="more"></span><p>在这篇博客中我将根据具体例题讲解部分dfs思路，正如上面所说，思想和实现能力是相辅相成的，我在这里理清了思路，还需要进行一个系列题目的练习，才能说把思路巩固了。如果有能力再进行高级的练习以及对于题目变形的解答。我希望在讲解的过程中也可以教学相长，如有错漏还请不吝赐教。</p><h1 id="正文（例题）"><a href="#正文（例题）" class="headerlink" title="正文（例题）"></a>正文（例题）</h1><h2 id="HDU-2553-N皇后问题"><a href="#HDU-2553-N皇后问题" class="headerlink" title="HDU 2553 N皇后问题"></a>HDU 2553 N皇后问题</h2><p>n皇后问题就是最经典的dfs问题，一般的n皇后问题主要求解的是解的个数或者摆放的位置图。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="http://http//acm.hdu.edu.cn/showproblem.php?pid=2553" title="http://acm.hdu.edu.cn/showproblem.php?pid=2553">http://acm.hdu.edu.cn/showproblem.php?pid=2553</a></p><p><img src="https://www.z4a.net/images/2019/04/15/dfs-.jpg" alt="dfs-1.jpg"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我对思路的讲解将以八皇后为例子，即n取8时的思路。</p><p>首先，画出一个8*8的表格。</p><p><img src="https://www.z4a.net/images/2019/04/15/dfs-1.1.jpg" alt="dfs-1.1.jpg"></p><p>据题意可知，对于某一个点是否可以放置皇后的条件是同行同列或者一条斜线上不存在皇后。</p><p>我们从第一个点即[1][1]开始试图放置，由于同行同列以及一条斜线均无皇后（下称条件），故在[1][1]处放置皇后。</p><p><img src="https://www.z4a.net/images/2019/04/26/dfs-1.2.jpg" alt="dfs-1.2.jpg"></p><p>而在此时，按照普通的搜索方式，应该从[1][2]试图放置。但很明显[1][1]与[1][2]同处一行，违背了条件，可知一旦在该行放置了皇后就应该跳到下一行进行搜索，以减小时间复杂度。根据这些特性，我们可以规定棋盘的每一行为一层，进行不断的递归操作来遍历，这就是dfs的大概形式。</p><p>正如上段所说，第一行已经放置了皇后，搜索通过递归跳到了第二层，也就是第二行中。在第一个位置即[2][1]进行判断。由于第一列中已有皇后放置（[1][1]），故判断下一个位置[2][2]，由于同一斜线存在皇后（[1][1]），不满足条件故判断下一个位置[2][3]，发现满足条件，将第二行的皇后放置在第三列。</p><p><img src="https://www.z4a.net/images/2019/04/26/dfs-1.3.jpg" alt="dfs-1.3.jpg"></p><p>第二行也已经放置了皇后，通过递归跳到第三行，很明显第三行首先放在第五列，即[3][5]处。</p><p><img src="https://www.z4a.net/images/2019/04/26/dfs-1.4.jpg" alt="dfs-1.4.jpg"></p><p>dfs到达了第四层，第一列的位置由于已经放置了皇后（[1][1]），故跳过。[4][2]这个位置满足条件，故将皇后放置在此处。</p><p><img src="https://www.z4a.net/images/2019/04/26/dfs-1.5.jpg" alt="dfs-1.5.jpg"></p><p>据此规则判断出第五行放置在第四列即[5][4]处。</p><p><img src="https://www.z4a.net/images/2019/04/26/dfs-1.8.jpg" alt="dfs-1.6.jpg"></p><p>dfs到达第六层，可知前五列均无法放置皇后，而后三列也均由于前三行与其同处一条斜线上而不满足条件，如此第六行在当前状态没有满足条件的位置。故dfs进行回溯操作，dfs回溯至第五层。</p><p>在第五行的当前位置也即[5][4]处已被证明不行，则在下一个位置尝试即[5][5]，当然由于[3][5]与该位置处于同一列，不满足条件。在[5][6]和[5][7]都因为条件不满足而跳到下个位置，在[5][8]这个位置当前可行，则尝试该位置。</p><p><img src="https://www.z4a.net/images/2019/05/01/dfs-1.9.jpg" alt="dfs-1.7.jpg"></p><p>在第六行所有位置仍然均不满足条件，如此回溯到第五层，然而第五层已经到了最后一个位置，如此回溯第四层，尝试[4][7]这个位置。</p><p><img src="https://www.z4a.net/images/2019/05/01/dfs-1.10.jpg" alt="dfs-1.8.jpg"></p><p>通过各种尝试，得出第一种情况。</p><p><img src="https://www.z4a.net/images/2019/05/05/dfs-1.11.jpg" alt="dfs-1.11.jpg"></p><p>所有摆放情况都尝试过之后，总共有92种情况。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>下面放出我针对hdu2553 N皇后问题打出的代码：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;int sum=0,i,j;int num[15]=&#123;0&#125;;int q;int lie[15];int t;bool pd(int m,int o)&#123;    for(j=1;j&lt;=m-1;j++)    &#123;        if(lie[j]==o||abs(lie[j]-o)==abs(j-m))        &#123;            return false;        &#125;    &#125;    return true;&#125;void dfs(int n)&#123;    if(n==q+1)    &#123;        sum++;        return;    &#125;    else    &#123;        for(i=1;i&lt;=q;i++)        &#123;            if(pd(n,i))            &#123;                lie[n]=i;                dfs(n+1);                i=lie[n];            &#125;        &#125;    &#125; &#125;int main()&#123;    for(q=1;q&lt;=10;q++)    &#123;        sum=0;        memset(lie,0,sizeof(lie));        dfs(1);        num[q]=sum;    &#125;    while(1)    &#123;        sum=0;        scanf(&quot;%d&quot;,&amp;t);        if(t==0)        &#123;            break;        &#125;        printf(&quot;%d\n&quot;,num[t]);    &#125;    return 0;&#125;</code></pre><p>其中某些地方可以进行优化来缩减空间或者时间，但由于高中这么学的，所以在此就不作多少改动了。</p><h2 id="洛谷-P1605-迷宫"><a href="#洛谷-P1605-迷宫" class="headerlink" title="洛谷 P1605 迷宫"></a>洛谷 P1605 迷宫</h2><p>一个简单的裸dfs问题，当然用bfs也能做。</p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P1605" title="https://www.luogu.org/problem/P1605">https://www.luogu.org/problem/P1605</a></p><p><img src="https://www.z4a.net/images/2019/05/29/dfs-2.1.jpg" alt="dfs-2.1.jpg"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>下面我随便给出一组数据(题目样例给的太简单了……)来作图进行解释。</p><p>作图如下</p><p><img src="https://www.z4a.net/images/2019/06/01/dfs-2.2.jpg" alt="dfs-2.2.jpg"></p><p>蓝色方块表示起点，红色方块表示终点，黑色方块表示障碍物。</p><p>像以前的dfs讲解一样，我们也做一个堆栈用来解释递归过程。</p><p><img src="https://www.z4a.net/images/2019/06/03/dfs-2.3.jpg" alt="dfs-2.3.jpg"></p><p>首先，我们将(1,1)也就是起始点入栈。然后在每个当前格子，对于四个方向的试探定一个先后顺序，我在这里规定先向右试探，然后按顺时针顺序旋转。</p><p>按照这个顺序，我们首先应该试探(1,1)的右侧格子即(1,2)即(1+0,1+1)发现该格子既没有在地图边界之外，也是一个可行的格子(不是墙)。若该格子为目标点，则方案数应当加一，并且回溯。但很明显这个格子只是一个普通的可行点，把该格子入栈。</p><p><img src="https://www.z4a.net/images/2019/06/03/dfs-2.4.jpg" alt="dfs-2.4.jpg"></p><p>接下来，对于当前格子即(1,2)的四个方向可行性进行试探，按照规定，我们首先试探(1,2)右侧的格子即(1,3)，发现可行，进行入栈操作。</p><p><img src="https://www.z4a.net/images/2019/06/03/dfs-2.5.jpg" alt="dfs-2.5.jpg"></p><p>而对于(1,3)这个点，首先仍然按照规定，试探该点右侧的格子，发现是墙，即不可行点。故按照我先前定的规则，试探该点下侧的格子即(2,3)，发现该点可行，故入栈。</p><p><img src="https://www.z4a.net/images/2019/06/03/dfs-2.6.jpg" alt="dfs-2.6.jpg"></p><p>由此由于该线路剩下所有点右侧均为墙，均不可行，故均向下试探，省略过程。</p><p><img src="https://www.z4a.net/images/2019/06/03/dfs-2.7.jpg" alt="dfs-2.7.jpg"></p><p>最后，(4,3)点入栈，对于该点的右侧，下侧，左侧三个方向的试探均失败。向上试探时，(3,3)点虽然可行，但是该点在之前的路线中已经存在，故仍然不可再次访问，这点要记住，不然可能会出现无限循环情况。</p><p>对于(4,3)点四个方向的试探均失败，故进行回溯操作，回溯到上一层，即栈顶为(3,3)。</p><p><img src="https://www.z4a.net/images/2019/06/03/dfs-2.8.jpg" alt="dfs-2.8.jpg"></p><p>而对于(3,3)这个点来说，向下的试探已经做完，按照规定，向左试探与向上试探均失败，故进行回溯操作，回溯到(2,3)。按此规则，最终回溯到初始状态，即只有(1,1)在栈内的状态。</p><p><img src="https://www.z4a.net/images/2019/06/03/dfs-2.3.jpg" alt="dfs-2.3.jpg"></p><p>对于初始点即(1,1)的向右试探已经完成，执行向下试探，发现(2,1)可行，故将(2,1)入栈。</p><p><img src="https://www.z4a.net/images/2019/06/03/dfs-2.9.jpg" alt="dfs-2.9.jpg"></p><p>由此规则，直到(6,1)入栈，向右试探才变得可行，故(6,2)入栈。</p><p>按照规则，走到一半将呈现如下线路图。</p><p><img src="https://www.z4a.net/images/2019/06/03/dfs-2.10.jpg" alt="dfs-2.10.jpg"></p><p>在当前点即(7,8)按逆时针试探，应试探(7,7)点，(7,7)点可行，入栈，但是对于(7,7)来说，四个方向均失败，故回溯，在(7,8)点时，只能向上试探，故形成如下线路图。</p><p><img src="https://www.z4a.net/images/2019/06/03/dfs-2.11.jpg" alt="dfs-2.11.jpg"></p><p>在(6,4)点时，对四个方向试探均失败，故回溯。同理，回溯到了(5,8)，在该点向上试探，(4,8)，(3,8)接连入栈，走入了目标点所在路线。</p><p><img src="https://www.z4a.net/images/2019/06/03/dfs-2.12.jpg" alt="dfs-2.12.jpg"></p><p>方案数加一，并且因为到达目标点，回溯到上一层，即(3,7)。由于(3,7)对于上边的试探失败，故再次回溯到(3,8)，此次向上试探可行，故走入(2,8)(1,8)(1,7)(1,6)这条路。</p><p>路已经走到头，很明显可以得到一直回溯到(8,2)的结论。故当前栈顶为(8,2)。对于(8,2)来说，向右试探已经结束，向下试探越界不可行，向左试探可行，到达(8,1)到达(7,1)却无路可走，又回溯到(8,2)。</p><p>又回溯到(7,2)，向左试探，(7,1)入栈，(8,1)入栈，(8,2)入栈，再次进行之前那轮右侧的操作，直到又找到一种方案。方案数加一，很明显再次回溯到(7,2)，这次仍需回溯到(6,2)(6,1)。</p><p>将此过程进行完毕后，得出最终的方案数。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;int xa[8]=&#123;1,0,0,-1&#125;;int ya[8]=&#123;0,1,-1,0&#125;;int a[10][10]=&#123;0&#125;;int mak[10][10]=&#123;0&#125;;int sum=0;int n,m,t;int sx,sy,fx,fy,tx,ty;void dfs(int x,int y)&#123;    if(x==0||x==n+1||y==0||y==m+1)    &#123;        return;    &#125;    else if(a[x][y]==1||mak[x][y]==1)    &#123;        return;    &#125;    else if(x==fx&amp;&amp;y==fy)    &#123;        sum++;        return;    &#125;    else    &#123;        mak[x][y]=1;        for(int k=0;k&lt;=3;k++)        &#123;            dfs(x+xa[k],y+ya[k]);        &#125;        mak[x][y]=0;    &#125;&#125;int main()&#123;    int i;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t);    scanf(&quot;%d%d%d%d&quot;,&amp;sx,&amp;sy,&amp;fx,&amp;fy);    for(i=1;i&lt;=t;i++)    &#123;        scanf(&quot;%d%d&quot;,&amp;tx,&amp;ty);        a[tx][ty]=1;    &#125;    dfs(sx,sy);    printf(&quot;%d&quot;,sum);    return 0;&#125;</code></pre><h2 id="洛谷-P1706-全排列问题"><a href="#洛谷-P1706-全排列问题" class="headerlink" title="洛谷 P1706 全排列问题"></a>洛谷 P1706 全排列问题</h2><p>比较经典的问题，没啥好解释的，特别注意的也就是输出格式。</p><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P1706" title="https://www.luogu.org/problem/P1706">https://www.luogu.org/problem/P1706</a></p><p><img src="https://www.z4a.net/images/2019/06/04/dfs-3.1.jpg" alt="dfs-3.1.jpg"></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>输出自然数1到n所有不重复的排列，用我们的思维方式，很容易看出可以用dfs来解。</p><p>我们在此将第k次选择的数字，作为第k层的数字。以输入样例即3为例：每层都有三个可选项(1,2,3)，但是条件是已经选过的数字不可以再次选中，我们便可以用数组记录是否已经选中。</p><p>第一次也即第一层选中1，第二层选中2，第三层选中3。而到了这时候，k即层数已经等于n，答案序列已经得到了一个，故将其输出。</p><p>然后进行回溯操作，回溯到第二层，第二层选中3，第三层选中2，得到第二个答案。</p><p>如此操作，得出并且按格式输出全部答案。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;int n;int sum=0;int v[15]; int b[15];void dfs(int ceng)&#123;    int k;    for(int i=1;i&lt;=n;i++)    &#123;        if(v[i]==0)        &#123;            sum++;            b[sum]=i;            v[i]=1;            dfs(ceng+1);            sum--;            v[i]=0;        &#125;    &#125;    if(ceng==n)    &#123;        for(k=1;k&lt;=n;k++)        &#123;            printf(&quot;%5d&quot;,b[k]);        &#125;        printf(&quot;\n&quot;);        return;    &#125;&#125;int main()&#123;    scanf(&quot;%d&quot;,&amp;n);    dfs(1);    return 0;&#125;</code></pre><h2 id="洛谷-P1036-选数"><a href="#洛谷-P1036-选数" class="headerlink" title="洛谷 P1036 选数"></a>洛谷 P1036 选数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P1036" title="https://www.luogu.org/problem/P1036">https://www.luogu.org/problem/P1036</a></p><p><img src="https://www.z4a.net/images/2019/06/20/dfs-5.1.jpg" alt="dfs-5.1.jpg"></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>很明显，这道题是一道组合，按照我们正常的思维方式，自然能够想到dfs的解题思路。限界条件就是已选择的数字个数等于要求选择的数字个数。</p><p>以题目中所给数据为例，我们把第几个选择的数字当作第几层。如此，第一层我们首先选择第一个数字即3，然后第二层选择3之后的第一个数字即7，第三层选择12。已经选择了三个数字，进行判定，3+7+12&#x3D;22，22不是一个素数，故总数不变。</p><p>判定结束后，第三层重新选择，选择当前数字即12的下一个数字19。进行判定，3+7+19&#x3D;29是一个素数，故总数加一。这时第三层应该重新选择，但是19后面没有数字了，故第三层回溯到第二层，第二层进行重新选择，第二层选择了下一个数字即12，第三层选择19。3+12+19&#x3D;38，38不是一个素数。</p><p>第三层无法重新选择，回溯第二层，第二层重新选择到了19，第三层又没数可选，故回溯到第二层，回溯到第一层，第一层选择下一个数字即7，第二层是12，第三层是19。7+12+19&#x3D;34，不是一个素数。之后无情况出现，第一层无法选择，dfs结束。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;#include&lt;math.h&gt;int n,k;int a[25];int sum=0,sum1=0;int pd(int shu)&#123;    int i;    for(i=2;i&lt;=sqrt(shu);i++)    &#123;        if(shu%i==0)        &#123;            return 0;        &#125;    &#125;    return 1;&#125;void dfs(int ceng,int ge)&#123;    if(ceng==k)    &#123;        sum+=a[ge];        if(pd(sum)==1)        &#123;            sum1++;        &#125;        sum-=a[ge];        return;    &#125;    else    &#123;        sum+=a[ge];        for(int j=ge+1;j&lt;=n;j++)        &#123;            dfs(ceng+1,j);        &#125;        sum-=a[ge];    &#125;&#125;int main()&#123;    int i;    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    for(i=1;i&lt;=n;i++)    &#123;        scanf(&quot;%d&quot;,&amp;a[i]);    &#125;    for(i=1;i&lt;=n;i++)    &#123;        dfs(1,i);    &#125;    printf(&quot;%d&quot;,sum1);    return 0;&#125;</code></pre><h2 id="洛谷-AT1350-深さ優先探索"><a href="#洛谷-AT1350-深さ優先探索" class="headerlink" title="洛谷 AT1350 深さ優先探索"></a>洛谷 AT1350 深さ優先探索</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/AT1350" title="https://www.luogu.org/problem/AT1350">https://www.luogu.org/problem/AT1350</a></p><p><img src="https://s2.ax1x.com/2019/06/22/ZplZ0e.jpg" alt="dfs-6.1.jpg"></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>题目问高桥先生能否到达鱼店，很明显是一个地图类的搜索。地图类的搜索我也在上面的迷宫中讲过。这类题用dfs和bfs都可以，但是由于dfs代码编写简单，故我在此用dfs解题。</p><p>迷宫一题问有多少种方案，而这个题目问是否能够到达。这就是两个题目最大的区别，这个区别体现在已经回溯过的点是否有必要再次经过。对于这种是否连通的题目，已经回溯过的点确实可以再次经过，但该点衍生出的路径均已被证伪（若可以通向终点则已经跳出了搜索过程），所以再次对于该点的操作都是浪费时间。故我们可以记录每一个点是否已经经过。这种去掉无用操作的技巧叫做剪枝。</p><p>通过剪枝，我们可以大幅降低时间复杂度，在某些题目中，不剪枝会导致TLE（超时）。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;int jl=0;char a[505][505];int b[505][505]=&#123;0&#125;;int n,m;int xa[6]=&#123;1,-1,0,0&#125;;int ya[6]=&#123;0,0,1,-1&#125;;void dfs(int x,int y)&#123;    if(a[x][y]==&#39;g&#39;)    &#123;        jl=1;    &#125;    else if(x==0||x==n+1||y==-1||y==m||a[x][y]==&#39;#&#39;)    &#123;        return;    &#125;    else    &#123;        for(int k=0;k&lt;=3;k++)        &#123;            if(b[x+xa[k]][y+ya[k]]==0)            &#123;                b[x+xa[k]][y+ya[k]]=1;                dfs(x+xa[k],y+ya[k]);            &#125;        &#125;    &#125;&#125;int main()&#123;    int bei,bej;    int i,j;     scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    char c=getchar();    for(i=1;i&lt;=n;i++)    &#123;        gets(a[i]);    &#125;    for(i=1;i&lt;=n;i++)    &#123;        for(j=0;j&lt;=m-1;j++)        &#123;            if(a[i][j]==&#39;s&#39;)            &#123;                bei=i;                bej=j;            &#125;        &#125;    &#125;    dfs(bei,bej);    if(jl==1)    &#123;        printf(&quot;Yes&quot;);    &#125;    else    &#123;        printf(&quot;No&quot;);    &#125;    return 0;&#125;</code></pre><h2 id="POJ-2386-Lake-Counting"><a href="#POJ-2386-Lake-Counting" class="headerlink" title="POJ 2386 Lake Counting"></a>POJ 2386 Lake Counting</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p><a href="http://poj.org/problem?id=2386" title="http://poj.org/problem?id=2386">http://poj.org/problem?id=2386</a></p><p><img src="https://www.z4a.net/images/2019/06/24/dfs-7.1.jpg" alt="dfs-7.1.jpg"></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>这道题的表述大概为一个代表水的格子(W)，若周围八格也存在代表水的格子，则这些代表水的格子是同一个湖，最后要求得出湖的个数。</p><p>很明显的，该题是一道地图类搜索，bfs和dfs都可以做，但还是由于dfs编写简单，我选择用dfs解答。与一般的地图形dfs最显性的不同就是转移的方向由4个变成了8个。</p><p>我对题目所给的样例进行解释，题目给出的是10个字符串，首先需要对这些字符串进行处理，当然我把字符放进了二维数组（也可以把字符转化成数字放到二维整形数组中）。</p><p>总体的思路略有不同，因为询问整个地图中湖的个数，我们需要对整个地图进行穷竭搜索，对每一个点进行访问，判断是否是一个新的湖。有人可能会问，这不是没用dfs嘛……这里就出现了一个问题，新发现的这个W，是否与以前数过的W处于同一湖中，对于这个问题，我们进行如下操作。</p><p><img src="https://www.z4a.net/images/2019/06/26/dfs-7.2.jpg" alt="dfs-7.2.jpg"></p><p>对于新发现的一个W，对该位置进行dfs搜索（具体搜索的过程与上述地图类dfs相差无几）。穷竭搜索过程中，发现了（1，1）这个点的W，首先把该点的值赋成代表无水点的标志（这一步至关重要！！！），对于该点进行dfs搜索过程，我们从右侧开始逆时针进行试探，可以发现右侧直到下侧都没有W，到了右下的点即（2，2），发现了W，第二层变成了（2，2），与此同时，这个点也被赋值成点。dfs过程结束之后，处于地图左上角的这个湖已经被填成了平地，并且湖的总个数已经变成了1。至此，对于（1，1）这个点的穷竭搜索已经完成，向后面进行搜索。</p><p>下一个新出现的W在（1，10）这个点，按照上述方式填平右侧的湖，湖的总数目变成了2。</p><p>随后，前五行均为代表平地的标志了。穷竭搜索到了第六行，搜索到了（6，3）这个点，对该点进行dfs之后，左下角的湖已经填平，总数变成了3，整个地图已经全变成了平地，穷竭搜索仍然会一直搜索到最后一行的最后一个节点。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;char a[105][105];int xa[8]=&#123;1,1,1,0,0,-1,-1,-1&#125;;int ya[8]=&#123;1,0,-1,1,-1,1,0,-1&#125;;int sum=0;int n,m;int i,j;void dfs(int x,int y)&#123;    if(x==0||x==n+1||y==0||y==m+1)    &#123;        return;    &#125;    else if(a[x][y]==&#39;.&#39;)    &#123;        return;    &#125;    else    &#123;        a[x][y]=&#39;.&#39;;        for(int k=0;k&lt;=7;k++)        &#123;            dfs(x+xa[k],y+ya[k]);        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    char c=getchar();    for(i=1;i&lt;=n;i++)    &#123;        for(j=1;j&lt;=m;j++)        &#123;            scanf(&quot;%c&quot;,&amp;a[i][j]);        &#125;        c=getchar();    &#125;    for(i=1;i&lt;=n;i++)    &#123;        for(j=1;j&lt;=m;j++)        &#123;            if(a[i][j]==&#39;W&#39;)            &#123;                sum++;                dfs(i,j);            &#125;        &#125;    &#125;    printf(&quot;%d&quot;,sum);    return 0;&#125;</code></pre><h2 id="洛谷-P1451-求细胞数量"><a href="#洛谷-P1451-求细胞数量" class="headerlink" title="洛谷 P1451 求细胞数量"></a>洛谷 P1451 求细胞数量</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P1451" title="https://www.luogu.org/problem/P1451">https://www.luogu.org/problem/P1451</a></p><p><img src="https://www.z4a.net/images/2019/06/26/dfs-8.1.jpg" alt="dfs-8.1.jpg"></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>与上一道POJ的题目思路一样，不同的是这道题中数字1~9代表细胞。</p><p>没啥好说的……</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;char a[105][105];int xa[8]=&#123;1,0,0,-1&#125;;int ya[8]=&#123;0,1,-1,0&#125;;int sum=0;int n,m;int i,j;void dfs(int x,int y)&#123;    if(x==0||x==n+1||y==-1||y==m)    &#123;        return;    &#125;    else if(a[x][y]==&#39;0&#39;)    &#123;        return;    &#125;    else    &#123;        a[x][y]=&#39;0&#39;;        for(int k=0;k&lt;=3;k++)        &#123;            dfs(x+xa[k],y+ya[k]);        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    char c=getchar();    for(i=1;i&lt;=n;i++)    &#123;        scanf(&quot;%s&quot;,a[i]);    &#125;    for(i=1;i&lt;=n;i++)    &#123;        for(j=0;j&lt;=m-1;j++)        &#123;            printf(&quot;%c&quot;,a[i][j]);        &#125;    printf(&quot;\n&quot;);    &#125;    for(i=1;i&lt;=n;i++)    &#123;        for(j=0;j&lt;=m-1;j++)        &#123;            if(a[i][j]!=&#39;0&#39;)            &#123;                sum++;                dfs(i,j);            &#125;        &#125;    &#125;    printf(&quot;%d&quot;,sum);    return 0;&#125;</code></pre><h2 id="POJ-1088-滑雪"><a href="#POJ-1088-滑雪" class="headerlink" title="POJ 1088 滑雪"></a>POJ 1088 滑雪</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><p><a href="http://poj.org/problem?id=1088" title="http://poj.org/problem?id=1088">http://poj.org/problem?id=1088</a></p><p><img src="https://www.z4a.net/images/2019/06/26/dfs-9.1.jpg" alt="dfs-9.1.jpg"><br><img src="https://www.z4a.net/images/2019/06/26/dfs-9.2.jpg" alt="dfs-9.2.jpg"></p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>这道题也是一道地图类的搜索问题，但是与上述题都有不同的是这道题的数据范围，行数和列数最大值都为100，而对于每个点进行dfs相当于最大10^4次dfs，再细化计算的话基本可以确定会TLE。</p><p>但是自己模拟两遍的话就又会发现一些特征，如果这条路是递减的话，无论从哪里走到这里，这条路都是递减的，所以我就会有这样一个想法：是不是可以直接在那个位置直接记录由该位置所联通的最长路径。当由其他点经由dfs到达该点可以直接继承该点的最长路径数而不用多次进行重复操作，这也算另一种意义上的剪枝。</p><p>（貌似是叫做记忆化搜索？？？）</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;int h[105][105],v[105][105];int xa[8]=&#123;1,0,0,-1&#125;;int ya[8]=&#123;0,1,-1,0&#125;;int r,c;int sum,max1,max;void dfs(int x,int y)&#123;    if(x==0||x==r+1||y==0||y==c+1)    &#123;        return;    &#125;    else if(v[x][y]!=1)    &#123;        sum+=v[x][y];        if(sum&gt;max1)        &#123;            max1=sum;        &#125;        if(sum&gt;max)        &#123;            max=sum;        &#125;        sum-=v[x][y];        return;    &#125;    else    &#123;        sum+=1;        if(sum&gt;max)        &#123;            max=sum;        &#125;        if(sum&gt;max1)        &#123;            max1=sum;        &#125;        for(int k=0;k&lt;=3;k++)        &#123;            if(h[x+xa[k]][y+ya[k]]&lt;h[x][y])            &#123;                dfs(x+xa[k],y+ya[k]);            &#125;        &#125;        sum-=1;    &#125;&#125;int main()&#123;    int i,j;    scanf(&quot;%d%d&quot;,&amp;r,&amp;c);    for(i=1;i&lt;=r;i++)    &#123;        for(j=1;j&lt;=c;j++)        &#123;            scanf(&quot;%d&quot;,&amp;h[i][j]);            v[i][j]=1;        &#125;    &#125;    for(i=1;i&lt;=r;i++)    &#123;        for(j=1;j&lt;=c;j++)        &#123;            dfs(i,j);            v[i][j]=max1;            max1=0;        &#125;    &#125;    printf(&quot;%d&quot;,max);    return 0;&#125;</code></pre><h2 id="洛谷-P1506-拯救oibh总部"><a href="#洛谷-P1506-拯救oibh总部" class="headerlink" title="洛谷 P1506 拯救oibh总部"></a>洛谷 P1506 拯救oibh总部</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.luogu.org/problem/P1506" title="https://www.luogu.org/problem/P1506">https://www.luogu.org/problem/P1506</a></p><p><img src="https://www.z4a.net/images/2019/08/12/dfs-10.1.jpg" alt="dfs-10.1.jpg"></p><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>我们通过看样例和题目可以看出，一个不会被淹到的区域，外围一定是* 。我们可以对最外围的一圈进行dfs，然后把所有的0也就是洪水可以淹没的地方赋值成* ，然后对整个地图进行搜索，查找0的数量。</p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre><code>#include&lt;stdio.h&gt;int xa[5]=&#123;-1,0,1,0&#125;;int ya[5]=&#123;0,-1,0,1&#125;;char map[505][505];int n,m;int sum=0;void dfs(int x,int y)&#123;    for(int i=0;i&lt;=3;i++)    &#123;        if(x+xa[i]&gt;=0&amp;&amp;x+xa[i]&lt;=n&amp;&amp;y+ya[i]&gt;=0&amp;&amp;y+ya[i]&lt;=m)        &#123;            if(map[x+xa[i]][y+ya[i]]==&#39;0&#39;)            &#123;                map[x+xa[i]][y+ya[i]]=&#39;*&#39;;                dfs(x+xa[i],y+ya[i]);            &#125;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=0;i&lt;=n-1;i++)    &#123;        scanf(&quot;%s&quot;,map[i]);    &#125;    for(int t=0;t&lt;=m;t++)        &#123;        if(map[0][t]==&#39;0&#39;)        &#123;            dfs(0,t);            map[0][t]=&#39;*&#39;;        &#125;        if(map[n-1][t]==&#39;0&#39;)        &#123;            dfs(n-1,t);            map[n-1][t]=&#39;*&#39;;        &#125;    &#125;    for(int t=0;t&lt;=n;t++)    &#123;        if(map[t][0]==&#39;0&#39;)        &#123;            dfs(t,0);            map[t][0]=&#39;*&#39;;        &#125;        if(map[t][m-1]==&#39;0&#39;)        &#123;            dfs(t,m-1);            map[t][m-1]=&#39;*&#39;;        &#125;    &#125;    for(int i=0;i&lt;=n-1;i++)    &#123;        for(int j=0;j&lt;=m-1;j++)            &#123;            if(map[i][j]==&#39;0&#39;)            &#123;                sum++;            &#125;        &#125;    &#125;    printf(&quot;%d&quot;,sum);    return 0;&#125;</code></pre><h1 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在我看来，每种算法都由两个部分组成，一部分是思想，另外一部分就是实现能力，二者缺一不可。缺少思想，算法就无法站住，或者可以说固定的模板无法和灵活的题目相联系。缺少实现能力，算法就成了空中楼阁，你想到的思路再清晰再高明，打不出来终究是心有余力不足。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://www.unknown9t.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索算法" scheme="http://www.unknown9t.com/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
    <category term="dfs" scheme="http://www.unknown9t.com/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>dfs与bfs简单辨析</title>
    <link href="http://www.unknown9t.com/2022/04/29/dfs%E4%B8%8Ebfs%E7%AE%80%E5%8D%95%E8%BE%A8%E6%9E%90/"/>
    <id>http://www.unknown9t.com/2022/04/29/dfs%E4%B8%8Ebfs%E7%AE%80%E5%8D%95%E8%BE%A8%E6%9E%90/</id>
    <published>2022-04-29T13:44:02.936Z</published>
    <updated>2019-08-13T07:12:19.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>dfs即深度优先搜索(deep first search)与bfs即宽度优先搜索(breadth first search)究竟有哪些不同，本文将会依据我自己的理解，做出一定深度的阐述。</p><span id="more"></span><p>首先，需要大家清楚，dfs通常与栈这种数据结构相联系，bfs则与队列联系紧密，这两种数据结构的特性决定了其与算法内在必然的关系。两种搜索算法都应用了递归的思想，所以有相关知识的浏览者能够很快理解。</p><p>接下来我将结合具体图形进行分析。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><p><img src="https://www.z4a.net/images/2019/03/27/35e7b7a6ce3a912a4937eb5ae891b063.jpg" alt="二叉树.jpg"></p><p>我们以该二叉树为例结合堆栈示意图，先讲解dfs递归的过程。</p><p>首先我们将整棵树的根节点即1节点入栈。</p><p><img src="https://www.z4a.net/images/2019/03/27/1.2.jpg" alt="1.jpg"></p><p>然后查找1节点下是否有子节点，发现了2节点，我们把2节点入栈。</p><p><img src="https://www.z4a.net/images/2019/03/27/25cd058d4e5c5dd6d.jpg" alt="2.jpg"></p><p>如此查找到4节点下有子节点7，7节点下没有子节点，此时栈中已经有了四个节点。</p><p><img src="https://www.z4a.net/images/2019/03/27/3fb1e4f4fb44cf919.jpg" alt="3.jpg"></p><p>7节点下没有子节点，代表该路径已经到底，所以向上一层回溯，7节点出栈，查询4节点有没有除7节点外的子节点，发现8节点，8节点入栈。</p><p><a href="https://www.z4a.net/image/7pdHYn"><img src="https://www.z4a.net/images/2019/03/27/4d3641ffa9766b890.jpg" alt="4.jpg"></a></p><p>这时对8节点查询，发现8节点并没有子节点，向上回溯，到4节点，发现4节点也没有其余子节点，继续回溯，找到2节点，查询2节点。通过查询2节点，发现了2节点下的5节点，以及5节点下的9节点。</p><p><img src="https://www.z4a.net/images/2019/03/27/589a1c72a1f611c14.jpg" alt="5.jpg"></p><p>对9节点查询，无子节点，回溯到5节点，回溯到2节点，发现2节点无其余子节点，回溯到1节点，查询后发现3节点，6节点，10节点这条路。回溯到6节点，又发现3节点，6节点，11节点这条路。最后回溯到根节点1，搜索工作完成。</p><p>通过这个过程可以明显的感觉到深度优先搜索是一种一条路走到黑的搜索算法。</p><h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><p><img src="https://www.z4a.net/images/2019/03/27/35e7b7a6ce3a912a4937eb5ae891b063.jpg" alt="二叉树.jpg"></p><p>我们以同一棵二叉树为例，配合队列示意图，进行bfs的讲解。</p><p>首先同样将根节点即1节点入队。</p><p><img src="https://www.z4a.net/images/2019/03/28/629c2518999bca16a.jpg" alt="6.jpg"></p><p>与dfs不同的是，我们不再只盯着1节点的某一个子节点，而是将所有1的子节点入队，很明显1的子节点有2节点和3节点，所以将2节点和3节点入队。与此同时，1节点完成了自己的使命，1节点出队。</p><p><img src="https://www.z4a.net/images/2019/03/28/715fddd333e363943.jpg" alt="7.jpg"></p><p>这时用同样的操作处理队首，即当前处于队首位置的2节点，搜索2节点的子节点可知4节点和5节点，将4、5两节点入队，2节点出队。</p><p><img src="https://www.z4a.net/images/2019/03/28/87b5709f353fbc420.jpg" alt="8.jpg"></p><p>搜索3节点，6节点入队，3节点出队。</p><p><img src="https://www.z4a.net/images/2019/03/28/9f622bd9ba65ced8f.jpg" alt="9.jpg"></p><p>然后是7、8两节点入队，4节点出队。</p><p><img src="https://www.z4a.net/images/2019/03/28/10ef0bf3a1d93f2af7.jpg" alt="10.jpg"></p><p>然后5节点出队，5节点的子节点9节点入队，6节点出队，10节点和11节点入队。</p><p><img src="https://www.z4a.net/images/2019/03/28/1119ee0b902004cb60.jpg" alt="11.jpg"></p><p>7节点到了队首的位置，对7节点进行搜索，发现7节点没有子节点，则只进行7节点的出队操作。同理，当前队列中五个节点全部出队之后，队列变成了空队列，广度搜索过程结束，搜索工作完成。</p><p>而通过bfs，我们可以很清楚的感觉到，bfs完整的进行同层操作，在当前层的节点全部遍历后才会处理下一层的节点。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;dfs即深度优先搜索(deep first search)与bfs即宽度优先搜索(breadth first search)究竟有哪些不同，本文将会依据我自己的理解，做出一定深度的阐述。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://www.unknown9t.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="搜索算法" scheme="http://www.unknown9t.com/tags/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    
    <category term="dfs" scheme="http://www.unknown9t.com/tags/dfs/"/>
    
    <category term="bfs" scheme="http://www.unknown9t.com/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>常用技巧精选</title>
    <link href="http://www.unknown9t.com/2022/04/29/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E7%B2%BE%E9%80%89/"/>
    <id>http://www.unknown9t.com/2022/04/29/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E7%B2%BE%E9%80%89/</id>
    <published>2022-04-29T13:35:55.191Z</published>
    <updated>2019-08-13T03:53:18.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文所涉及的多种技巧，出自秋叶拓哉的《挑战程序设计》一书。译者提及这些技巧的应用范围都比书中所介绍的模型要广泛，我们应该注重算法技巧中蕴含的算法思想以及思维方式。许多看似复杂困难的问题，关键都可以运用看似简单的技巧处理。我查询网上对于这些技巧的解释，希望能够深化这种技巧蕴含的思想，并且将其变为自己的东西。</p><span id="more"></span><h1 id="技巧精选"><a href="#技巧精选" class="headerlink" title="技巧精选"></a>技巧精选</h1><h2 id="尺取法"><a href="#尺取法" class="headerlink" title="尺取法"></a>尺取法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>尺取法通常是指对数组保存一对下标（起点，终点），然后根据实际情况交替推进两个端点知道得出答案的方法，这种操作很像是尺蠖（日文中称为尺取虫）爬行的方式故得名（这是书中译者注释）。</p><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>说到底，尺取法只是一种模拟方法，通过模拟尺取虫的前进方式不断移动所选区间，验证区间内元素和题目所给条件是否符合。一般是在给的一组数据中找到不大于某一个上限的“最优连续子序列” 。而通过这种方法，能够将这一类问题的时间复杂度降低。</p><p>那么什么时候能够使用尺取法呢，不能使用尺取法的题目贸然使用一定会导致错误答案或者其他错误。</p><p>尺取法通常适用于我们所要选取的区间有明显的变化趋势的题目。换句话说，我们需要知道这次变动之后，下一步所选区间变化的方向或者形式。一般确定了可以应用尺取法之后，所取区间的左右端点都应从数组左端开始选取。</p><p>假如给你一些数，需要在这些数中找到一个区间，使得区间里每一个元素的和大于或等于给定的某个值。若不用尺取法，我们需要对于每一个区间的起始点，枚举终点，加和起点与终点之间的元素。这个过程需要开二重循环，就算有所剪枝，时间复杂度也是在O(n^2)左右。在这个过程中，我们很明显可以发现区间中元素的加和出现了重复累赘的地方，这些加和的过程和剪枝的过程叠加在一起就得到了尺取法的初始模型。</p><p>以上题为例，当我们现在所选区间的和不足给定的值，则区间的终点右移，区间和加上刚进入区间的点的值。而当我们现在所选区间和超过了给定的值，则区间起点右移，区间和减去刚出区间的点的值。这样我们可以得到每一个满足条件的区间。很明显可得，运用尺取法的思想，时间复杂度变成了O(n)。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="POJ-3061-Subsequence"><a href="#POJ-3061-Subsequence" class="headerlink" title="POJ 3061 Subsequence"></a>POJ 3061 Subsequence</h4><p>这道题是《挑战程序设计》书中第一道例题，大意就是求总长不小于S的连续子序列的长度的最小值，若解不存在，则输出0。</p><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p><a href="http://poj.org/problem?id=3061" title="http://poj.org/problem?id=3061">http://poj.org/problem?id=3061</a></p><p><img src="https://www.z4a.net/images/2019/07/26/-1.1.jpg" alt="-1.1.jpg"></p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>书中提及，本题可以用前缀和加二分法将O(n^2)的时间复杂度缩减至O(nlogn)。首先前缀和可以让查询区间和的时间复杂度变成O(1)，然后我们确定区间的起点，通过二分法枚举区间终点，最终复杂度变成O(nlogn)。</p><p>这时我们开始讲解尺取法的该题解题思路，假设以a[s]开始总和最初大于S时的连续子序列为a[s]+a[s+1]+…+a[t-1]。此时，a[s+1]+…+a[t-2]&lt;a[s]+…+a[t-2]&lt;S。所以从a[s+1]开始总和最初超过S的连续子序列如果是a[s+1]+…+a[t’-1]的话，则必然有t&lt;&#x3D;t’。</p><p>利用这个特性，我们可以得出只要当前区间和小于S，就把区间终点右移的思路，而区间和大于等于S的时候，就把区间起点右移。</p><p><img src="https://www.z4a.net/images/2019/07/26/-1.2.jpg" alt="-1.2.jpg"></p><p>通过这样一个模拟的过程，我们可以很轻松得出最小长度。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code>#include&lt;stdio.h&gt;int main()&#123;    int n;    int lo,s;    int a[100005];    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)    &#123;        scanf(&quot;%d%d&quot;,&amp;lo,&amp;s);        for(int j=1;j&lt;=lo;j++)        &#123;            scanf(&quot;%d&quot;,&amp;a[j]);        &#125;        int l=1,r=1,sum=a[1],min=100005;        while(1)        &#123;            if(sum&lt;s&amp;&amp;r&lt;lo)            &#123;                r++;                sum+=a[r];            &#125;            else if(sum&gt;=s)            &#123;                    if(r-l+1&lt;min)                &#123;                    min=r-l+1;                &#125;                sum-=a[l];                l++;            &#125;                else if(sum&lt;s&amp;&amp;r&gt;=lo)                &#123;                    break;            &#125;        &#125;        if(min==100005)        &#123;            printf(&quot;0\n&quot;);        &#125;        else        &#123;            printf(&quot;%d\n&quot;,min);        &#125;    &#125;    return 0;&#125;</code></pre><h2 id="反转（开关问题）"><a href="#反转（开关问题）" class="headerlink" title="反转（开关问题）"></a>反转（开关问题）</h2><h1 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本文所涉及的多种技巧，出自秋叶拓哉的《挑战程序设计》一书。译者提及这些技巧的应用范围都比书中所介绍的模型要广泛，我们应该注重算法技巧中蕴含的算法思想以及思维方式。许多看似复杂困难的问题，关键都可以运用看似简单的技巧处理。我查询网上对于这些技巧的解释，希望能够深化这种技巧蕴含的思想，并且将其变为自己的东西。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://www.unknown9t.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="算法技巧" scheme="http://www.unknown9t.com/tags/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://www.unknown9t.com/2022/04/29/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://www.unknown9t.com/2022/04/29/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2022-04-29T13:33:00.885Z</published>
    <updated>2019-04-15T08:37:46.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这篇文章所要讲的二分查找，是一种效率很高的查找方法。二分查找可以将查找的时间复杂度降至*O(log2n)*，但是它要求所查找的数列至少是有序数列。在大部分题目中，这个数列会被规定为有序且连续，但在某些题目中，数列不是连续的，而如果无法查找到，则输出固定语句。这些大同小异，但是用二分查找的前提一定是该数列有序。 </p><span id="more"></span><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h2><p>当我们在电话本中查找我们想要的人的电话号码时，我们通常知道想要查找的人的姓名，而电话本中记录的顺序完全按照姓名字母的字典序。我们通常如何查找？</p><p>先翻到电话本的一半，判断一半时候的姓名字母是在目标姓名字母的前边还是后边，然后再在目标姓名字母存在的部分继续上述过程，最终可以查到目标电话号码，这就是二分查找的具体应用之一。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://www.z4a.net/images/2019/04/08/11227bde54ff43061.jpg" alt="二分查找1.jpg"></p><p>如图所示，在当前数列中查找6是否存在，若存在，输出其其中一个序号。</p><p>已知当前数列为非递减数列。首先，确定left为数列最左端，right为数列最右端。即left为1，right为11。设置mid变量，存储数列中点序号。在当前图所示状态下，mid取值为6，即6为该数列当前中点，只需比较所求数与中点所对应的数字。</p><p>由于9&gt;6，可知所求数所对应序号只可能在6之前，也就是只可能存在于1到6之间。故用当前mid-1替换当前right。（之所以用mid-1是为了防止出现无限循环的情况）</p><p><img src="https://www.z4a.net/images/2019/04/08/28856195014f52f18.jpg" alt="二分查找2.jpg"></p><p>此时mid为（1+5）&#x2F;2即3。将所求数与序号3对应数字对比，5&lt;6，故所求数所对应序号只可能在3后，也就是只可能存在于3到6之间。故用当前mid+1替换当前left。（原因同上）</p><p><img src="https://www.z4a.net/images/2019/04/08/38bc81c2b76e1909b.jpg" alt="二分查找3.jpg"></p><p>此时mid为（4+5）&#x2F;2即4。将所求数与序号4对应数字对比，发现正好相等。代表该数列中6确实存在，故可以输出目标数字对应的序号。</p><p>若left&gt;right，代表给出的数列已经查找完，没有发现目标数字。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>应用二分查找法的前提一定是有序数列。</li><li>二分查找法在应用时应密切注意各变量的限值重叠交叉问题，不然可能会出现死循环。</li></ol><h2 id="标准代码"><a href="#标准代码" class="headerlink" title="标准代码"></a>标准代码</h2><p>给出我手打的标准代码（默认给出的15个数有序）</p><pre><code>#include&lt;stdio.h&gt;int main()&#123;    int l,r,i;    int goal;    int mid;    int pd=0;    int a[20];    scanf(&quot;%d&quot;,&amp;goal);    for(i=1;i&lt;=15;i++)    &#123;        scanf(&quot;%d&quot;,&amp;a[i]);    &#125;    l=1;    r=15;    while(l&lt;=r)    &#123;        mid=(l+r)/2;        if(a[mid]==goal)        &#123;            printf(&quot;%d&quot;,mid);            pd=1;            break;        &#125;        else if(a[mid]&lt;goal)        &#123;            l=mid+1;        &#125;        else        &#123;            r=mid-1;        &#125;    &#125;    if(pd==0)    &#123;        printf(&quot;no answer&quot;);    &#125;    return 0;&#125;</code></pre><p>通常的，每一个二分查找的题目中应包含两个条件。一个是判断找到的标准，一个是判断无法找到的精度。在我上面的代码中，找到的标准就是目标数字等于了当前判断的数字，代表二分查找已经查找到了。判断精度则是无限接近于0，原因是我判断的标准是当l&gt;r时结束。在某些题目中，精度有明显给出，可以写成r-l&lt;精度的格式。有时，判断精度也可通过固定循环次数代替。</p><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><p>先提一句，在openjudge–noi上面有一个系列共十道二分法的题目。</p><h3 id="查找最接近的元素–openjudge-noi"><a href="#查找最接近的元素–openjudge-noi" class="headerlink" title="查找最接近的元素–openjudge-noi"></a>查找最接近的元素–openjudge-noi</h3><p><a href="http://noi.openjudge.cn/ch0111/01/" title="openjudge-noi1">http://noi.openjudge.cn/ch0111/01/</a></p><p><img src="https://www.z4a.net/images/2019/04/12/4.2.jpg" alt="二分查找4.1.jpg"></p><p>基本是道裸二分查找，没啥好说的……</p><p>打出了ac代码，emmm我代码风格也不好，各人有各人的作法……</p><pre><code>#include&lt;stdio.h&gt;#include&lt;math.h&gt;int a[100005]=&#123;-1&#125;;int l,r;int n,m,t;int i;int mid,ans,ans1;int jdz(int cs)&#123;    if(cs&lt;0)    &#123;        return -cs;    &#125;    else    &#123;        return cs;    &#125;&#125; int bj(int a1,int a2,int p)&#123;    if(a1==-1)    &#123;        a1=-999;    &#125;    if(a2==-1)    &#123;        a2=-999;    &#125;    if(jdz(a1-p)&lt;=jdz(a2-p))    &#123;        return a1;    &#125;    else    &#123;        return a2;    &#125;&#125;int cz(int q)&#123;    l=1;    r=n;    while(l&lt;=r)    &#123;        mid=(l+r)/2;        if(a[mid]&lt;=q)        &#123;            l=mid+1;        &#125;        else        &#123;            r=mid-1;        &#125;    &#125;    mid=(l+r)/2;    ans1=bj(a[mid],a[mid+1],q);    a[0]=-1;    a[n+1]=-1;    return ans1;&#125;int main()&#123;    scanf(&quot;%d&quot;,&amp;n);    for(i=1;i&lt;=n;i++)    &#123;        scanf(&quot;%d&quot;,&amp;a[i]);    &#125;    scanf(&quot;%d&quot;,&amp;m);    for(i=1;i&lt;=m;i++)    &#123;        scanf(&quot;%d&quot;,&amp;t);        ans=cz(t);        printf(&quot;%d\n&quot;,ans);    &#125;    return 0;&#125; </code></pre><h3 id="二分法求函数的零点–openjudge-noi"><a href="#二分法求函数的零点–openjudge-noi" class="headerlink" title="二分法求函数的零点–openjudge-noi"></a>二分法求函数的零点–openjudge-noi</h3><p><a href="http://noi.openjudge.cn/ch0111/02/" title="openjudge-noi2">http://noi.openjudge.cn/ch0111/02/</a></p><p><img src="https://www.z4a.net/images/2019/04/12/4.3.jpg" alt="二分查找4.3.jpg"></p><p>也是道裸二分查找，跟上面那题难度相差不多，也就是个精度问题。</p><h3 id="x的平方根–leetcode（力扣网）"><a href="#x的平方根–leetcode（力扣网）" class="headerlink" title="x的平方根–leetcode（力扣网）"></a>x的平方根–leetcode（力扣网）</h3><p><a href="https://leetcode-cn.com/problems/sqrtx/" title="力扣网">https://leetcode-cn.com/problems/sqrtx/</a></p><p><img src="https://www.z4a.net/images/2019/04/11/3.1.jpg" alt="二分查找4.2.jpg"></p><p>这道题是一道二分答案的题目，可以看出精度部分可以取0.01，通过不断假设答案是当前值，然后不断二分得到最接近的结果，通过检验得出答案，不是很难……</p><h2 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h2><p>未完待续……</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;这篇文章所要讲的二分查找，是一种效率很高的查找方法。二分查找可以将查找的时间复杂度降至*O(log2n)*，但是它要求所查找的数列至少是有序数列。在大部分题目中，这个数列会被规定为有序且连续，但在某些题目中，数列不是连续的，而如果无法查找到，则输出固定语句。这些大同小异，但是用二分查找的前提一定是该数列有序。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://www.unknown9t.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="查找算法" scheme="http://www.unknown9t.com/tags/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>个人常用OJ平台</title>
    <link href="http://www.unknown9t.com/2022/04/29/%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8OJ%E5%B9%B3%E5%8F%B0/"/>
    <id>http://www.unknown9t.com/2022/04/29/%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8OJ%E5%B9%B3%E5%8F%B0/</id>
    <published>2022-04-29T13:19:00.508Z</published>
    <updated>2019-04-12T13:32:00.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近在搜其他博客所需要的例题时，惊奇的发现原来OJ平台极多，而且仍有一些很有价值，很美观的OJ平台我并没有发现，或者说发现了却经常忘记用。所以，在这篇博文中我将记载一些个人觉得有必要记录的网站，并且分列它们的特点（每一个OJ平台都不是十全十美的，我觉得一个网站有些不足也是特色）。</p><span id="more"></span><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="hdu（杭州电子科技大学）"><a href="#hdu（杭州电子科技大学）" class="headerlink" title="hdu（杭州电子科技大学）"></a>hdu（杭州电子科技大学）</h2><p><a href="http://acm.hdu.edu.cn/" title="航电OJ">http://acm.hdu.edu.cn/</a></p><p>从高中开始，竞赛老师就在推荐这个网站，到了大学，主要看基础题也是这个网站。大概是中国最受欢迎的OJ平台之一，题目数量很多。</p><p><img src="https://www.z4a.net/images/2019/04/11/hdu.jpg" alt="hdu.jpg"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>题目数量多，来源广，英文题很多，评测系统以及网站本身比较稳定。<br>本身特点大概是很多题有无限组数据，有的题输入数据时的处理比较繁琐，有些题的输出格式也比较繁琐。</p><h2 id="pku（北京大学poj）"><a href="#pku（北京大学poj）" class="headerlink" title="pku（北京大学poj）"></a>pku（北京大学poj）</h2><p><a href="http://poj.org/" title="北大OJ">http://poj.org/</a></p><p>北大这个OJ平台名气也很出众，对这个平台的印象是几乎全英文题库，我认为美化做的不如hdu。</p><p><img src="https://www.z4a.net/images/2019/04/11/pku.jpg" alt="pku.jpg"></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>不是很熟悉，不做太多评价，大概和hdu类型差不多。</p><h2 id="codevs（）"><a href="#codevs（）" class="headerlink" title="codevs（）"></a>codevs（）</h2><p><a href="http://www.codevs.cn/" title="codevs">http://www.codevs.cn/</a></p><p>我个人来说特别喜欢这个OJ平台，无论是美工还是题目的选择方面，而且这个平台陪伴了我整个高二，虽然当时没打多少题，但是有着满满的回忆。</p><p><img src="https://www.z4a.net/images/2019/04/11/codevs.jpg" alt="codevs.jpg"></p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>codevs里面按部分给分，并且有的时候会把错误数据显示出来，题目也不少。就是这个平台本身不是很稳定，到现在长时间某些功能无法正常运行，并且对题目的分类做的不好。正如之前所说，这个网站的美化做得很好，并且还自己做了等待提交结果时的小游戏。</p><h2 id="openjudge-noi"><a href="#openjudge-noi" class="headerlink" title="openjudge-noi ()"></a>openjudge-noi ()</h2><p><a href="http://noi.openjudge.cn/" title="openjudge-noi">http://noi.openjudge.cn/</a></p><p>这个网站也是从高中陪伴我的，openjudge其实是一整个大网站，里面包含很多小组，noi这个小组比较老，也比较规范。有兴趣的读者还可以去openjudge的其他小组看看，相信会有收获。</p><p><img src="https://www.z4a.net/images/2019/04/12/openjudge-noi.jpg" alt="openjudge-noi.jpg"></p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>与codevs不同，这个网站对于题目的类型分类很标准，也有很基础的题目。每一个大块知识点基本都有一个专项练习，比较适合想巩固某一方面能力的同学。但是这个网站基本早已经不再更新了，题目基本已经固定。</p><h2 id="PTA（拼题A）"><a href="#PTA（拼题A）" class="headerlink" title="PTA（拼题A）"></a>PTA（拼题A）</h2><p><a href="https://pintia.cn/" title="pta">https://pintia.cn/</a></p><p>这个网站是之前打天梯赛的时候集体刷题用的，只用了其中的一个团体程序设计天梯赛的习题集。别的习题集我并不是很感兴趣……</p><p><img src="https://www.z4a.net/images/2019/04/12/pta.jpg" alt="pta.jpg"></p><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><p>因为大多是历届真题，并且根据难度分好得分和等级了，所以团体程序设计天梯赛的习题集还挺好用的，别的习题集不是很清楚。</p><h2 id="nowcoder（牛客网-牛客竞赛）"><a href="#nowcoder（牛客网-牛客竞赛）" class="headerlink" title="nowcoder（牛客网 牛客竞赛）"></a>nowcoder（牛客网 牛客竞赛）</h2><p><a href="https://ac.nowcoder.com/acm/home" title="nowcoder">https://ac.nowcoder.com/acm/home</a></p><p>牛客网主页的在线编程功能或者说测试功能都很好用，并且牛客网对于求职方面有一定的帮助，我主要进入牛客网的牛客竞赛界面。</p><p><img src="https://www.z4a.net/images/2019/04/12/7d75135bbcf10e2d21bea3db78537aa0.jpg" alt="nowcoder.jpg"></p><h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><p>在牛客竞赛的界面既有练习题，也有线上赛。练习题分类也很明确，但是算法种类并没有很多，我平时也并不是在牛客网上找题，主要还是用牛客竞赛的线上赛。大概一周一次，每次等级难度都不同，读者可以根据自己的能力报名，并不收费，报名也可以不参加。</p><h2 id="leetcode（力扣）"><a href="#leetcode（力扣）" class="headerlink" title="leetcode（力扣）"></a>leetcode（力扣）</h2><p><a href="https://leetcode.com/" title="leetcode e">https://leetcode.com/</a></p><p><a href="https://leetcode-cn.com/" title="leetcode c">https://leetcode-cn.com/</a></p><p>分别为力扣网的官网和中国官网，读者用哪个都可以，新发现的一个OJ平台，最近还将举办一个力扣杯的比赛。</p><p><img src="https://www.z4a.net/images/2019/04/12/leetcode-e.jpg" alt="leetcode-e.jpg"></p><p><img src="https://www.z4a.net/images/2019/04/12/leetcode-c.jpg" alt="leetcode-c.jpg"></p><h3 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h3><p>题目数量不算多，但精度还行，分类做的比较完整。有自己的中英文切换，有积分兑换系统，美工做的也挺好的。而且在力扣阅读界面拥有官方给出的一些题目的多种解法，学习和测验效果也不错。</p><h2 id="lintcode（领扣）"><a href="#lintcode（领扣）" class="headerlink" title="lintcode（领扣）"></a>lintcode（领扣）</h2><p><a href="https://www.lintcode.com/" title="lintcode">https://www.lintcode.com/</a></p><p>也是一个新发现的OJ平台，具体怎么样还没有试过。</p><p><img src="https://www.z4a.net/images/2019/04/12/lintcode.jpg" alt="lintcode.jpg"></p><h3 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h3><p>貌似有针对人工智能的训练题，针对算法的题分类一般，题量也一般。（具体我也没好好看……）</p><h2 id="luogu（洛谷）"><a href="#luogu（洛谷）" class="headerlink" title="luogu（洛谷）"></a>luogu（洛谷）</h2><p><a href="https://www.luogu.org/" title="luogu">https://www.luogu.org/</a></p><p>一个针对noip的网站，大学也有用处。</p><p><img src="https://www.z4a.net/images/2019/04/12/6369b221bc143a42ddd18dff3c1c0ae5.jpg" alt="luogu.jpg"></p><h3 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h3><p>题量还挺足的，美工也偏软风，分类做的也不错。有兴趣可以常用。特别的是貌似学习了打怪人物制……</p><h2 id="vijos（VJ）"><a href="#vijos（VJ）" class="headerlink" title="vijos（VJ）"></a>vijos（VJ）</h2><p><a href="https://vijos.org/" title="VJ">https://vijos.org/</a></p><p>一开始总把这个网站和洛谷搞混，这些日子认清了……</p><p><img src="https://www.z4a.net/images/2019/04/12/vijos.jpg" alt="vijos.jpg"></p><h3 id="特点-9"><a href="#特点-9" class="headerlink" title="特点"></a>特点</h3><p>美工做的挺好的，题量中上，分类其实也不错。这个网站我很有好感，可以作为常用网站平时刷刷题。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>另外还有几个网站新近找出来的，有的是国外的网站，因为不太了解，所以我仅在这里提出网址，有兴趣的读者可以自选看看。</p><p><a href="https://www.jisuanke.com/" title="计蒜客">https://www.jisuanke.com/</a><br>计蒜客</p><p><a href="http://www.acmcoder.com/index" title="赛码网">http://www.acmcoder.com/index</a><br>赛码网</p><p><a href="http://uoj.ac/" title="uoj">http://uoj.ac/</a><br>uoj</p><p><a href="https://uva.onlinejudge.org/" title="uva">https://uva.onlinejudge.org/</a><br>uva（国外）</p><p>或许未完待续……</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;最近在搜其他博客所需要的例题时，惊奇的发现原来OJ平台极多，而且仍有一些很有价值，很美观的OJ平台我并没有发现，或者说发现了却经常忘记用。所以，在这篇博文中我将记载一些个人觉得有必要记录的网站，并且分列它们的特点（每一个OJ平台都不是十全十美的，我觉得一个网站有些不足也是特色）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="杂论" scheme="http://www.unknown9t.com/tags/%E6%9D%82%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯和天梯赛赛后感受</title>
    <link href="http://www.unknown9t.com/2022/04/29/%E8%93%9D%E6%A1%A5%E6%9D%AF%E4%B8%8E%E5%A4%A9%E6%A2%AF%E8%B5%9B%E8%B5%9B%E5%90%8E%E6%84%9F%E5%8F%97/"/>
    <id>http://www.unknown9t.com/2022/04/29/%E8%93%9D%E6%A1%A5%E6%9D%AF%E4%B8%8E%E5%A4%A9%E6%A2%AF%E8%B5%9B%E8%B5%9B%E5%90%8E%E6%84%9F%E5%8F%97/</id>
    <published>2022-04-29T12:47:57.664Z</published>
    <updated>2019-04-01T15:10:59.583Z</updated>
    
    <content type="html"><![CDATA[<p>2019年4月1日，是四月的第一天，也是新的一周的开始。上周六刚去北京打了一场天梯赛，回想起来，感触还是挺多的，所以决定和上上周日打的蓝桥杯一起，写一篇赛后的感受，自己菜就要多反省自己为什么菜。</p><span id="more"></span><p>因为天梯赛是十人团体赛，蓝桥杯是个人赛，所以备赛重点放在了天梯赛上。一开始认为蓝桥杯比天梯赛难一些，抱着去参观的心态去打的，便没有太大的心理压力（也是因为是个人赛，自己菜不会影响队友）。乍一看题，并没有过脑子，想当然的忽略了很重要的条件，便先丢五分。随后更是在一些地方，犯下了低级的错误，是一道排序找最大公约数的题，被我当成了排序之后直接找最小差值的题，真的是没用脑子。还有题只让输出后四位的，我却直接输出了全部，而且完全没有注意数过大溢出之后，由负变正的可能，直接觉得得出了正确答案。</p><p>打完蓝桥杯，和学长和同学对过题之后，感觉自己的脑子真的一团乱麻，自己把这场比赛当成参观就真的去参观了。这首先是态度和心理问题，其次也是自己的技术问题，一些本能性注意的东西，直接被我过滤掉了，真正的比赛中一点点的小错，可能会让我和得奖失之交臂。</p><p>说完自己不好的地方，说说仍有希望的地方吧。蓝桥杯我只打了两个小时就出场了，一个原因是对于鼠标键盘确实不适应，当时的环境也给了我很大的心理压力，第二个原因就是我对于题有些轻视，没有检查自己对于题意的理解是否正确。假设我没有提前离场，仍有可能与当前分数一样，但我更相信自己可以检查出这些错漏的地方。</p><p>至于天梯赛，我确实准备了一些东西，在赛前也做过一些题目，模拟赛也打了，但是到了正式赛，我认为成绩确实不如我的心意。虽然有题目难的原因，但是我觉得我不应该把比赛的失败推诿给环境因素。大家比赛的环境因素几近完全相同，为什么我却不能适应难一些的基础题型，这确实给我上了一节课。</p><p>打完天梯赛我也自闭了两天，期间倒没有想太多东西，就是觉得自己努力的不够。我不能只和周围暂时没我分高的同学比较，我应该和比我更强大的同届同学相比，甚至与上一届的学长相较量。我与这些人相比，无论是技术层面，还是主观的努力方面都远远不如。我虽然还可以用我还年轻来麻痹自己或者给予自己信心，但是我觉得大一下学期已经不年轻了，天梯赛里中学生队伍都在我之上，我已经没有理由不去努力了。</p><p>又因为一些原因，看到了北大的大神吉如一对本次比赛的看法，深深觉得自己的不足。百度了一下吉如一的简介，大神从初中接触算法，始终保持的热爱与兴趣，是我梦寐以求的。</p><p>如今，我希望可以通过自己的努力，达成自己的目标。希望我可以不断地学习，终于有一天可以尽自己的力，做自己喜欢做的事。</p><p><img src="https://www.z4a.net/images/2019/04/01/tts.jpg" alt="tts.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2019年4月1日，是四月的第一天，也是新的一周的开始。上周六刚去北京打了一场天梯赛，回想起来，感触还是挺多的，所以决定和上上周日打的蓝桥杯一起，写一篇赛后的感受，自己菜就要多反省自己为什么菜。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>写在一切之前</title>
    <link href="http://www.unknown9t.com/2022/04/29/%E5%86%99%E5%9C%A8%E4%B8%80%E5%88%87%E4%B9%8B%E5%89%8D/"/>
    <id>http://www.unknown9t.com/2022/04/29/%E5%86%99%E5%9C%A8%E4%B8%80%E5%88%87%E4%B9%8B%E5%89%8D/</id>
    <published>2022-04-29T12:42:03.370Z</published>
    <updated>2019-03-28T15:13:25.641Z</updated>
    
    <content type="html"><![CDATA[<p>这个博客是为了我能够不断督促自己学习算法，并且提醒自己充分享受算法所给我带来的乐趣而搭建的。当然，如果浏览这个博客的人觉得某些文章对你也有些用处，那也算是我做了一些好事。我希望自己可以不忘初心，永远保持对算法的热爱，无论身在何方，无论什么身份。</p><span id="more"></span><p>搭建这个博客用了<em>hexo</em>和<em>github</em>的一些知识，有兴趣的浏览者可以去<em>bilibili</em>搜索相关视频，其中遇到了很多困难，但是在同学的帮助下克服了，友链中就有同学搭建的博客，真的非常感谢。</p><p>总的来说，有了这个博客，我的算法复习将会更加系统，在学习过程中也会清晰的查漏补缺，可以达到更好的学习效果，希望自己可以越来越强。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个博客是为了我能够不断督促自己学习算法，并且提醒自己充分享受算法所给我带来的乐趣而搭建的。当然，如果浏览这个博客的人觉得某些文章对你也有些用处，那也算是我做了一些好事。我希望自己可以不忘初心，永远保持对算法的热爱，无论身在何方，无论什么身份。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
